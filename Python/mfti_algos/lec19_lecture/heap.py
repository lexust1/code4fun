# Свойства кучи:

# Свойство Полноты:
# Куча - это полное бинарное дерево, что позволяет эффективно
# представлять её в виде массива.

# Свойство Порядка:
# В минимальной куче значение каждого родительского узла меньше
# или равно значениям его дочерних узлов. В максимальной куче - наоборот.

# Эффективность Основных Операций:
# Вставка, удаление и поиск мин./макс. элементов имеют логарифмическую
# временную сложность.

# Ограничение на Глубину Листьев:
# Листья находятся на двух последних уровнях, глубина которых
# отличается не более чем на один уровень, обеспечивая
# сбалансированность дерева.
import heapq


class Heap:
    def __init__(self):
        """Инициализирует объект кучи.
        Асимптотика: O(1), так как выполняется только присвоение начальных значений.
        """
        # Инициализация пустого списка для хранения элементов кучи
        self.values = []
        # Инициализация размера кучи как 0
        self.size = 0

    def __str__(self):
        """Возвращает строковое представление объекта кучи.
        Асимптотика: O(1), предполагая, что операция форматирования строки не зависит от размера кучи.
        """
        # Возвращает строковое представление кучи
        return f"Heap: {self.values}"

    def insert(self, x):
        """Вставляет элемент в кучу и восстанавливает свойства кучи.
        Асимптотика: O(log n), где n - размер кучи, так как элемент может перемещаться вверх до корня.
        """
        # Добавляет новый элемент в конец списка
        self.values.append(x)
        # Увеличивает размер кучи на 1
        self.size += 1
        # Вызывает sift_up для нового элемента
        self.sift_up(self.size - 1)

    def sift_up(self, idx):
        """Просеивает элемент вверх по куче для восстановления свойств кучи.
        Асимптотика: O(log n), где n - размер кучи, так как элемент может перемещаться вверх до корня.
        """
        # Цикл продолжается до тех пор, пока не достигнут корень кучи (idx > 0)
        # и текущий элемент меньше его родительского элемента.
        while idx > 0 and self.values[idx] < self.values[(idx - 1) // 2]:
            # Вычисляем индекс родительского элемента
            parent_idx = (idx - 1) // 2
            # Меняем местами текущий элемент с его родителем.
            self.values[idx], self.values[parent_idx] = self.values[parent_idx], self.values[idx]
            # Обновляем индекс idx, чтобы продолжить просеивание вверх,
            # если это необходимо (например, если текущий элемент все еще меньше своего нового родителя).
            idx = parent_idx

    def sift_down(self, idx):
        """Просеивает элемент вниз по куче для восстановления свойств кучи.
        Асимптотика: O(log n), где n - размер кучи, так как элемент может перемещаться вниз до листа.
        """
        # Пока у узла есть левый дочерний элемент
        while 2 * idx + 1 < self.size:
            # Считаем, что текущий узел (idx) является наименьшим
            smallest = idx
            # Проверяем, меньше ли левый дочерний узел, чем текущий узел
            # Если да, то теперь наименьший узел - левый дочерний
            if self.values[2 * idx + 1] < self.values[idx]:
                smallest = 2 * idx + 1
            # Проверяем, существует ли правый дочерний узел и меньше ли он,
            # чем текущий наименьший узел.
            # Если да, то теперь наименьший узел - правый дочерний
            if 2 * idx + 2 < self.size and self.values[2 * idx + 2] < self.values[smallest]:
                smallest = 2 * idx + 2
            # Если текущий узел уже наименьший (не изменился после проверок),
            # завершаем цикл
            if idx == smallest:
                break
            # Меняем местами текущий узел и найденный наименьший дочерний узел
            self.values[idx], self.values[smallest] = self.values[smallest], self.values[idx]
            # Обновляем idx для следующей итерации цикла
            idx = smallest

    def extract_min(self):
        """Извлекает минимальный элемент из кучи и восстанавливает свойства кучи.
        Асимптотика: O(log n), где n - размер кучи, так как после извлечения корня необходимо восстановить кучу.
        """
        # Если куча пуста, возвращаем None
        if not self.size:
            return None
        # Сохраняем минимальный элемент
        tmp = self.values[0]
        # Перемещаем последний элемент на место первого
        self.values[0] = self.values[-1]
        # Удаляем последний элемент
        self.values.pop()
        # Уменьшаем размер кучи
        self.size -= 1
        # Восстанавливаем свойства кучи
        self.sift_down(0)
        # Возвращаем минимальный элемент
        return tmp

    def find_min(self):
        """Возвращает минимальный элемент кучи.
        Асимптотика: O(1), так как минимальный элемент находится в корне кучи.
        """
        # Находит минимум кучи (по сути, возвращает значение корня)
        return self.values[0] if self.size > 0 else None

    @staticmethod
    def heapify(arr):
        """Преобразует кучу в отсортированный массив, извлекая минимальные элементы.
        Асимптотика: O(n log n), где n - размер кучи, так как каждое извлечение имеет сложность O(log n).
        """
        # Создаем новый объект кучи
        heap = Heap()
        # Вставляем каждый элемент массива в кучу
        for el in arr:
            heap.insert(el)
        return heap

    @staticmethod
    def get_sorted_arr(heap):
        """Преобразует кучу в отсортированный массив, извлекая минимальные элементы.
        Асимптотика: O(n log n), где n - размер кучи, так как каждое извлечение имеет сложность O(log n).
        """
        # Инициализируем пустой массив для отсортированных элементов
        sorted_arr = []
        # Извлекаем минимальный элемент из кучи и добавляем его в массив
        # При извлечении минимума "под капотом" идет поддержание свойств кучи.
        while heap.size:
            sorted_arr.append(heap.extract_min())
            print(sorted_arr)
        return sorted_arr

    @staticmethod
    def heapify_fast(arr):
        """
        Быстро преобразует массив в минимальную кучу, начиная с середины массива.
        Асимптотика: O(n), где n - количество элементов массива, благодаря более
        эффективному методу построения кучи.

        Основная разница между heapify и heapify_fast заключается в
        способе построения кучи. В то время как heapify вставляет
        элементы по одному, вызывая sift_up для каждого из них,
        heapify_fast начинает с середины массива и применяет
        sift_down к каждому родительскому узлу. Это гораздо быстрее,
        так как такой подход сразу формирует правильную структуру кучи
        без необходимости многократного просеивания элементов вверх.

        Метод reversed(range(heap.size // 2)) начинает с середины
        массива (или последнего родительского узла) и движется к корню
        кучи, что обеспечивает корректное построение минимальной кучи.

        Однако этот метод плохо подходит, когда надо добавлять все-таки
        по одному элементу из-за необходимости еще каких-то операций
        между вставками.
        """
        # Создаем новый объект кучи
        heap = Heap()
        # Копируем элементы из исходного массива
        heap.values = arr[:]
        # Устанавливаем размер кучи равным размеру массива
        heap.size = len(arr)
        # Проходим по всем родительским узлам кучи в обратном порядке
        # и применяем метод sift_down к каждому из них.
        # Это быстрее, чем последовательное добавление элементов в кучу,
        # поскольку сразу формирует корректную кучу из всего массива.
        for i in reversed(range(heap.size // 2)):
            heap.sift_down(i)
        return heap


def main():
    # Тестируем insert
    arr = [3, 5, 7, 8, 10, 13, 6]
    h1 = Heap()
    h1.insert(3)
    print(h1)
    h1.insert(5)
    print(h1)
    h1.insert(7)
    print(h1)
    h1.insert(8)
    print(h1)
    h1.insert(10)
    print(h1)
    h1.insert(13)
    print(h1)
    h1.insert(6)
    print(h1)

    h2 = Heap()
    for value in arr:
        h2.insert(value)
        print(h2)

    heap = []
    for value in arr:
        heapq.heappush(heap, value)
        print(heap)

    # Тестируем extract_min
    while h2.size > 0:
        h2.extract_min()
        print(h2)

    while heap:
        heapq.heappop(heap)
        print(heap)

    # Тестируем сортировку
    Heap.get_sorted_arr(Heap.heapify(arr))

    Heap.get_sorted_arr(Heap.heapify_fast(arr))

    # Сортировка при помощи встроенных методов.
    print("heapq")
    arr = [3, 5, 7, 8, 10, 13, 6]
    print(arr)
    heapq.heapify(arr)
    print(arr)
    sorted_arr = [heapq.heappop(arr) for _ in range(len(arr))]
    print(sorted_arr)


if __name__ == "__main__":
    main()
