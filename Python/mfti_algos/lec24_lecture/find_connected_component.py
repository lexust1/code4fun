# Обход в глубину (Depth-First Search, DFS) — это один из основных
# алгоритмов для обхода или поиска элементов в графе или дереве.
# Этот алгоритм начинает свою работу с корневого узла (или с любого
# другого указанного узла) и продвигается вглубь графа, насколько это
# возможно, на каждом шаге переходя от текущей вершины к одной из еще
# не посещенных соседних вершин, пока это возможно.
#
# Когда алгоритм достигает вершины, у которой нет не посещенных
# соседних узлов, он отступает (делает шаг назад) к предыдущей в
# ершине и повторяет процесс, пока не будут исследованы все возможные
# пути от исходной точки. Если остаются не посещенные вершины, алгоритм
# выбирает одну из них и повторяет процесс.
#
#
# Выделение связной компоненты (connected component, vertex component)
# Компонента вершины (или связная компонента): Это подмножество графа,
# в котором любые две вершины соединены путем (последовательностью
# рёбер). Связная компонента представляет собой максимальный
# связный подграф в ненаправленном графе, то есть подграф, который
# нельзя расширить, добавив еще одну вершину из остальной части графа
# и сохраняя связность. В контексте направленных графов, аналогичные
# понятия - это сильно связная и слабо связная компоненты.
import networkx as nx
import matplotlib.pyplot as plt


def dfs(graph, vertex, visited=None):
    """
    Выполняет обход в глубину (DFS) для графа.

    Args:
    graph: Словарь, представляющий граф (ключи - вершины, значения -
        множества смежных вершин).
    vertex: Начальная вершина для DFS.
    visited: Множество посещенных вершин.

    Returns:
    Множество посещенных вершин.
    """
    # Если множество посещенных вершин не задано, создаем пустое множество
    if visited is None:
        visited = set()
    # Добавляем текущую вершину в множество посещенных
    visited.add(vertex)
    # Перебираем всех соседей текущей вершины
    for neighbour in graph[vertex]:
        # Если соседняя вершина еще не посещена, рекурсивно вызываем
        # функцию dfs для нее
        if neighbour not in visited:
            dfs(graph, neighbour, visited)
    # Возвращаем множество посещенных вершин
    return visited


def count_connected_components(graph):
    """
    Подсчитывает количество связных компонент в графе.

    Args:
    graph: Словарь, представляющий граф.

    Returns:
    Количество связных компонент в графе.
    """
    # Инициализация множества для отслеживания посещенных вершин
    visited = set()
    # Счетчик количества связных компонент
    num_components = 0
    # Перебор всех вершин графа с целью запуска dfs в каждой из них
    for vertex in graph:
        # Если текущая вершина еще не была посещена
        if vertex not in visited:
            dfs(graph, vertex, visited)
            # Увеличиваем счетчик связных компонент, так как нашли новую компоненту
            num_components += 1
    # Возвращаем общее количество связных компонент
    return num_components


def draw_graph(graph):
    """
    Отображает граф с использованием библиотеки NetworkX.

    Args:
    graph: Словарь, представляющий граф.
    """
    # Создание экземпляра графа NetworkX
    G = nx.Graph()
    # Добавление узлов и ребер в граф
    # Перебор всех вершин и их соседей в предоставленном словаре графа
    for vertex, neighbors in graph.items():
        # Добавление вершины в граф
        G.add_node(vertex)
        # Добавление ребра между текущей вершиной и каждым из ее соседей
        for neighbor in neighbors:
            G.add_edge(vertex, neighbor)
    # Вывод списка узлов и ребер графа
    print(G.nodes)
    print(G.edges)
    # Визуализация графа с помощью NetworkX
    nx.draw(
        G,  # Граф, который необходимо отобразить
        with_labels=True,  # Включение отображения меток (названий) узлов
        node_color='lightblue',  # Цвет узлов
        edge_color='gray',  # Цвет ребер
        node_size=2000,  # Размер узлов
        font_size=15  # Размер шрифта меток узлов
    )
    # Отображение визуализации графа
    plt.show()


def main():
    graph = {'1': {'2', '3'},
             '2': {'1', '4', '5'},
             '3': {'1'},
             '4': {'2'},
             '5': {'3', '4', '2'}}

    draw_graph(graph)
    print("dfs from node 1:", dfs(graph, "1"))
    print("num of components:", count_connected_components(graph))


if __name__ == "__main__":
    main()
