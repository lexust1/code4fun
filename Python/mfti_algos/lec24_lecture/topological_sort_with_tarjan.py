# Топологическая сортировка — это упорядочивание вершин ациклического
# ориентированного графа (Directed Acyclic Graph, DAG)
# таким образом, что для каждого направленного ребра от вершины U к
# вершине V, вершина U предшествует вершине V в порядке сортировки.
# Это означает, что если существует путь от U к V, то U всегда будет
# расположена перед V в упорядоченном списке.

# Топологическая сортировка часто используется в сценариях, где данные
# нужно обрабатывать в определенном порядке,
# например, в планировании задач или разрешении зависимостей в
# системах управления пакетами.

# Алгоритм Тарьяна для топологической сортировки — это метод,
# использующий глубокий обход в глубину (Depth-First Search, DFS)
# для идентификации порядка, в котором вершины должны быть обработаны.
# Процесс включает в себя следующие шаги:
# 1. Выбор Непосещенной Вершины: Начать с любой непосещенной вершины.
# 2. Рекурсивный Обход в Глубину: Применить DFS к текущей вершине,
# рекурсивно посещая все смежные и еще не посещенные вершины.
# 3. Формирование Стека Завершения: После посещения всех смежных
# вершин и возвращения из рекурсивных вызовов, добавить текущую
# вершину в стек (или в начало списка).
# 4. Результат: После обработки всех вершин, порядок, в котором они
# были добавлены в стек, и будет являться топологически отсортированным
# порядком.

# Алгоритм Тарьяна эффективен и обеспечивает возможность получения
# топологической сортировки за время, пропорциональное количеству
# вершин плюс количество рёбер графа (O(V + E)).

def dfs(graph, vertex, visited, ans):
    """
    Функция для рекурсивного обхода графа и выполнения топологической
    сортировки при помощи dfs.

    Args:
    graph (dict): Граф, представленный в виде словаря множеств.
    vertex (int): Текущая вершина для обхода.
    visited (set): Множество посещенных вершин.
    ans (list): Список для сохранения порядка топологической сортировки.
    """
    # Добавление текущей вершины в множество посещенных
    visited.add(vertex)
    # Перебор все соседей
    for neighbour in graph[vertex]:
        # Если соседа не посещал
        if neighbour not in visited:
            # Рекурсивный вызов для соседей
            dfs(graph, neighbour, visited, ans)
    # Добавление вершины в список после посещения всех соседей
    ans.append(vertex)


def tarjan(graph):
    """
    Функция для выполнения топологической сортировки графа.

    Args:
    graph (dict): Граф, представленный в виде словаря множеств.

    Returns:
    list: Список вершин, упорядоченных согласно топологической
        сортировки.
    """
    # Список для хранения порядка топологической сортировки
    ans = []
    # Множество для отслеживания посещенных вершин
    visited = set()
    # Вызов DFS для каждой непосещенной вершины (а не соседа), по сути,
    # со стартом из разных вершин.
    for vertex in graph:
        if vertex not in visited:
            # Обход в глубину для каждой вершины
            dfs(graph, vertex, visited, ans)
    # Реверсирование списка для получения правильного порядка
    ans[:] = ans[::-1]
    return ans


def main():
    graph = {
        0: {2, 3},
        1: {3, 4},
        2: {5},
        3: {5, 6},
        4: {6},
        5: {7},
        6: {7},
        7: set()
    }
    print(tarjan(graph))


if __name__ == "__main__":
    main()
