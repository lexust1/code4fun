def traj_num(N):
    """Кол-во траекторий, если  кузнечик прыгает на +1 или +2."""
    # Кузнечик может прыгать на 1 или 2 единицы вправо.
    # Необходимо определить количество различных маршрутов, чтобы
    # добраться до точки n.
    #
    # Для этого используем динамическое программирование:
    # f(n) - количество маршрутов для достижения точки n.
    #
    # Кузнечик может попасть в точку n двумя способами:
    # 1. Прыжок из точки n-1 (на одну единицу).
    # 2. Прыжок из точки n-2 (на две единицы).
    #
    # Таким образом, f(n) = f(n-1) + f(n-2) (сводится к поиску числа
    # Фибоначчи).
    # Это означает, что количество маршрутов в точку n равно сумме
    # маршрутов в точки n-1 и n-2.
    # Используя эти начальные условия и рекурсивное соотношение,
    # мы можем вычислить f(n) для любого n.
    K = [0, 1] + [0] * (N - 1)
    for i in range(2, N + 1):
        K[i] = K[i - 2] + K[i - 1]
    return K[N]


def count_trajectories(N, allowed):
    """То же самое, но можно теперь прыгать на +3, при этом нельзя
    наступать на 4 и 7 клетки."""
    K = [0, 1, int(allowed[2])] + [0] * (N - 2)
    for i in range(3, N + 1):
        if allowed[i]:
            K[i] = K[i - 3] + K[i - 2] + K[i - 1]
    return K[N]


def count_min_cost(N, price):
    """Минимальная стоимость достижения клетки, при этом допустимы
    прыжки только +1 и +2."""
    C = [float("-inf"), price[1], price[1] + price[2]] + [0] * (N - 2)
    for i in range(3, N + 1):
        C[i] = price[i] + min(C[i - 1], C[i - 2])
    return C[N]


def main():
    N = 10
    # traj_num
    print(traj_num(N))
    # count_trajectories
    allowed = [1] * (N + 1)
    allowed[3], allowed[6] = 0, 0
    print(count_trajectories(N, allowed))
    # count_min_cost
    print(count_min_cost(4, [0, 2, 3, 5, 1]))


if __name__ == "__main__":
    main()
