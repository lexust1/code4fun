# В лекции почти не было практических примеров реализации самих методов.
# Как сказал лектор, реализация любой из этих структур данных, как
# реализация отдельного курсового проекта. Поэтому дали только базовые
# принципы. Возможно, реализую сам в будущем.
# Полезные ссылки на реализацию различных дереверь на Python:
# https://shunsvineyard.info/2021/07/02/build-the-forest-in-python-series-avl-tree-vs-red-black-tree/
# https://github.com/burpeesDaily/forest-python/tree/main/forest/binary_trees

# АВЛ-деревья и красно-черные деревья — это два типа самобалансирующихся
# бинарных деревьев поиска. Они обеспечивают относительно высокую
# эффективность операций добавления, удаления и поиска элементов за
# счет поддержания сбалансированной структуры дерева. Хэш-таблицы,
# с другой стороны, используют совсем другой принцип организации
# данных, основанный на хэшировании.
#
# АВЛ-деревья
# АВЛ-деревья (названы в честь их изобретателей Адельсона-Вельского и
# Ландиса) поддерживают строгий баланс по высоте поддеревьев, для
# каждого узла разница высот левого и правого поддерева не превышает 1.
# Это обеспечивает гарантированную высоту дерева в худшем случае
# логарифмическую от количества элементов, что делает операции поиска,
# вставки и удаления эффективными за O(log(N))
#
# Красно-черные деревья
# Красно-черные деревья — это другой тип самобалансирующихся бинарных
# деревьев поиска. Они обеспечивают баланс за счет поддержания четырех
# свойств, связанных с цветом узлов (каждый узел либо красный, либо
# черный) и структурой дерева. Как и АВЛ-деревья, красно-черные деревья
# обеспечивают логарифмическое время выполнения основных операций, но
# они могут быть менее строго сбалансированы по сравнению с
# АВЛ-деревьями. Однако красно-черные деревья часто требуют меньше
# поворотов при вставке и удалении, что может сделать их более
# быстрыми в некоторых ситуациях.
#
# Хэш-таблицы
# Хэш-таблицы — это структуры данных, которые предоставляют очень
# быстрый доступ к элементам по ключу за счет использования хэш-функции
# для преобразования ключа в индекс в массиве. В идеальном случае
# хэш-таблицы могут предоставлять доступ к элементам, вставку и
# удаление за постоянное время O(1). Однако в реальности коллизии
# хэш-функций (когда разные ключи имеют одинаковый хэш) могут ухудшить
# производительность, требуя дополнительного времени для разрешения
# коллизий.
#
# Сравнение
# Время выполнения: АВЛ и красно-черные деревья обеспечивают
# логарифмическое время выполнения операций в худшем случае, в то
# время как хэш-таблицы могут обеспечить доступ за постоянное время в
# среднем случае.

# Упорядочение: АВЛ и красно-черные деревья поддерживают
# упорядоченность элементов, что позволяет выполнять дополнительные
# операции, такие как поиск следующего/предыдущего элемента. Хэш-таблицы
# не поддерживают упорядоченность.

# Память: см. ниже

# Гибкость: АВЛ и красно-черные деревья более гибки в плане выполнения
# различных видов запросов, таких как диапазонный поиск.
# Выбор между этими структурами данных зависит от конкретных требований
# приложения, таких как необходимость поддержания порядка элементов,
# ожидаемое количество операций вставки/удаления по сравнению с
# операциями поиска, и ограничения по памяти.

# При сравнении использования памяти между АВЛ-деревьями, красно-черными
# деревьями и хэш-таблицами, нельзя дать однозначный ответ, так как это
# зависит от конкретных реализаций и условий использования. Однако
# можно рассмотреть некоторые общие принципы и факторы, влияющие на
# использование памяти в каждой из этих структур данных.
#
# АВЛ-деревья и красно-черные деревья
# Узлы дерева: Каждый узел в АВЛ и красно-черных деревьях хранит данные,
# ключ, ссылки на левое и правое поддеревья, а также, в случае
# АВЛ-деревьев, информацию о высоте для каждого узла. В красно-черных
# деревьях для каждого узла также хранится информация о цвете (красный
# или черный).

# Балансировка: АВЛ-деревья требуют хранения дополнительной информации
# о высоте поддеревьев для каждого узла, что может немного увеличить
# общее потребление памяти по сравнению с красно-черными деревьями,
# где хранится только информация о цвете узла.

# Хэш-таблицы
# Массивы и связные списки (или деревья): Хэш-таблицы обычно используют
# массив для хранения данных, где каждый элемент массива может быть
# указателем на связный список (или дерево) для разрешения коллизий.
# Память, используемая хэш-таблицей, зависит от размера массива (который
# может быть больше количества хранимых элементов для снижения количзий)
# и от структур данных, используемых для разрешения коллизий.

# Фактор загрузки:
# Чтобы поддерживать эффективность операций,
# хэш-таблицы должны поддерживать определенный фактор загрузки
# (0.5-0.8), что часто приводит к необходимости резервирования большего
# объема памяти, чем строго необходимо для хранения текущего количества
# элементов.

# Сравнение

# Память под управляющие структуры:
# Хэш-таблицы могут использовать больше памяти на управляющие структуры
# (например, большие массивы для уменьшения количества коллизий), в то
# время как самобалансирующиеся деревья используют дополнительную
# память на узле для поддержания баланса.

# Плотность данных: В самобалансирующихся деревьях плотность данных
# может быть выше, так как каждый узел содержит только один элемент
# данных, в то время как в хэш-таблицах может быть много неиспользуемого
# пространства из-за необходимости поддерживать низкий фактор загрузки
# для эффективности.

# В общем, хэш-таблицы могут быть более требовательны к памяти,
# особенно когда важно минимизировать коллизии для поддержания высокой
# производительности. С другой стороны, АВЛ и красно-черные деревья
# могут быть более эффективными по использованию памяти в сценариях,
# где количество элементов невелико или когда требуется поддерживать
# упорядоченность элементов.