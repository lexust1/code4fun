# Алгоритм Дейкстры с очередью через использование кучи.
# - Обход начинается с первой вершины
# - Из вершины определяется путь до каждого соседа. Если расстояние
# (путь) до соседа оказывается меньше, чем текущий, то мы таких соседей
# загоняем кучу. Из плюсов, что у нас наверху кучи всегда гранится
# вершина с минимальным путем. Это ускоряет алгоритм.
# - После просмотра всех соседей текущей вершины, если в очереди есть
# вершины, мы начинаем просматривать их соседей. И так до тех пор,
# пока очереде с приоритетом (куча) не закончится.

# Асимптотическая сложность алгоритма Дейкстры с использованием кучи:
#
# 1. Инициализация: Создание и инициализация словарей расстояний
# (distances) и предшественников (predecessors) для всех вершин
# требует O(V) операций, где V — количество вершин в графе. Также
# инициализация кучи с начальной вершиной требует O(1).
#
# 2. Основной цикл алгоритма: Алгоритм проходит через каждую вершину
# графа, потенциально добавляя вершины в кучу несколько раз.
# Операция добавления в кучу (heapq.heappush) и удаления из кучи
# (heapq.heappop) имеют сложность O(log V) для каждой операции.
# В худшем случае, каждое ребро может привести к добавлению вершины
# в кучу, что дает O(E log V), где E — количество рёбер.
#
# 3. Обновление расстояний: При обнаружении более короткого пути до
# соседней вершины, расстояние и предшественник обновляются, а вершина
# добавляется в кучу. Так как это происходит внутри цикла по соседям
# каждой вершины, общее количество таких операций пропорционально
# количеству рёбер, но выбор следующей вершины для обработки
# оптимизируется до O(log V).
#
# 4. Итоговая асимптотическая сложность: С учётом всех шагов, общая
# асимптотическая сложность алгоритма при использовании кучи составляет
# O((V + E) log V). Это более эффективно по сравнению с наивной
# реализацией без очереди с приоритетами, особенно в разреженных
# графах, где E намного меньше, чем V^2.
#
# Использование кучи позволяет эффективно управлять очередью вершин для
# обработки, всегда выбирая вершину с наименьшим известным расстоянием
# до начальной вершины, что значительно ускоряет поиск кратчайших путей.

# Еще существует вариант с кучей Фибоначи, где часть операций, который
# в бинарной куче выполняются за O(log(N)), выполняеются за O(1)
# (вставка, обновление и т.п.). Это тоже позволяет ускорить алгоритм.
import heapq


def create_adj_list():
    """
    Создает представление графа в виде списка смежности.

    Returns:
    graph: dict, представление графа в виде списка смежности
    """
    # Вводим количество вершин (n) и рёбер (m)
    n, m = [int(x) for x in input().split()]
    # Инициализируем граф
    graph = {}
    # Добавляем рёбра с весом
    for _ in range(m):
        v1, v2, weight = input().split()
        weight = float(weight)
        # Добавляем ребро в граф
        add_edge(graph, v1, v2, weight)
        # Добавляем обратное ребро в граф
        add_edge(graph, v2, v1, weight)
    return graph


def add_edge(graph, v1, v2, weight):
    """
    Добавляет ребро между двумя вершинами с заданным весом в граф.

    Args:
    graph (dict): Граф, в который будет добавлено ребро.
    v1: Первая вершина ребра.
    v2: Вторая вершина ребра.
    weight: Вес ребра.
    """
    if v1 not in graph:
        # Если вершина v1 отсутствует в графе, добавить её с словарём,
        # содержащим v2 как ключ и вес как значение
        graph[v1] = {v2: weight}
    else:
        # Если вершина v1 присутствует в графе, обновить словарь,
        # добавив v2 как ключ и вес как значение
        graph[v1][v2] = weight


def dijkstra(graph, start):
    """
    Реализация алгоритма Дейкстры для нахождения кратчайших путей от
    начальной вершины до всех остальных при помощи очереди с
    приоритетами через использование кучи.

    Args:
    graph (dict): Граф, представленный в виде словаря смежности.
    start: Начальная вершина, с которой начинается поиск.

    Returns:
    dict: Словарь предшественников, который позволяет восстановить
    кратчайший путь от начальной вершины до всех остальных.
    """
    # Создание словаря для хранения кратчайших расстояний от start до
    # каждой вершины
    distances = {i: float("inf") for i in graph}
    # Создаем кучу ("очередь" с приоритетами), в формате расстояние,
    # вершина
    heap = [(0, start)]
    # Установка расстояния до начальной вершины равным 0
    distances[start] = 0
    # Создаем словарь предшественников
    predecessors = {i: None for i in graph}
    while heap:
        # Извлекаем расстояние и узел из начала кучи.
        distance, vertex = heapq.heappop(heap)
        # Перебираем всех соседей текущего узла.
        for neighbour in graph[vertex]:
            # Находим новое расстояние до текущего соседа
            new_distance = distance + graph[vertex][neighbour]
            # Если вновь найденное расстояние до соседа оказывается
            # меньше текущего расстояния, то
            if new_distance < distances[neighbour]:
                # Обновляем расстояние до соседа
                distances[neighbour] = new_distance
                # И добавляем соседа с обновленным расстоянием в кучу,
                # чтобы искать дальше уже его соседей.
                # Важный момент, что здесь засчет использования кучи
                # мы всегда держим вершину с минимальным расстоянием
                # наверху, что позволяет быстрее извлекать минимум.
                heapq.heappush(heap, (new_distance, neighbour))
                # Сохраняем предшественника для соседа
                predecessors[neighbour] = vertex
    return predecessors


# В лекции предлагается вариант восстановления через обратный счет,
# т.е. из длину пути до последнего узла мы вычитаем длину ребра до
# каждого соседа, смотрим совпадение и двигаемся вперед. Интресный
# поход. Вероятно, хорош, когда мы хотим сэкономить место под хранение
# предшественников. Но с предшественниками подход более прозрачный,
# меньше расчетов и просто список узлов вряд ли может занимать много
# места даже для больших графов. Поэтому сохраняем тот подход, который
# был и при BFS.
def reconstruct_path(predecessors, start, end):
    """
    Восстанавливает путь в графе от начальной до конечной вершины,
    используя предоставленный словарь предшественников.

    Args:
    predecessors (dict): Словарь, где ключи - это вершины, а значения -
    их предшественники. Получается в результате выполнения функции bfs.
    start (str): Начальная вершина пути.
    end (str): Конечная вершина пути.

    Returns:
    list: Список вершин, составляющих кратчайший путь от start до end.
          Возвращает "No path", если путь не существует.
    """
    # Начинаем с конечной вершины
    vertex = end
    path = []
    # Перемещаемся по предшественникам от конечной вершины к начальной
    while vertex != start:
        # Добавляем текущую вершину в путь
        path.append(vertex)
        # Получаем предшественника текущей вершины
        vertex = predecessors[vertex]
        # Если для вершины нет предшественника, путь не существует
        if vertex is None:
            return "No path"
    # Добавляем начальную вершину в путь как остаток пути
    path.append(start)
    # Возвращаем путь в правильном порядке от начальной до конечной
    # вершины, т.к. реконструкция идет с конца.
    return path[::-1]


def main():
    # graph = create_adj_list()
    # print(graph)
    # # Граф с изолированной областью
    # graph = {
    #     'A': {'B': 2.0, 'H': 15.0},
    #     'B': {'A': 2.0, 'C': 1.0, 'D': 5.0},
    #     'C': {'B': 1.0, 'D': 3.0, 'G': 1.0, 'F': 2.0},
    #     'D': {'B': 5.0, 'C': 3.0, 'F': 4.0, 'E': 6.0},
    #     'G': {'C': 1.0, 'F': 1.0},
    #     'F': {'C': 2.0, 'D': 4.0, 'G': 1.0, 'E': 7.0, 'H': 3.0},
    #     'E': {'D': 6.0, 'F': 7.0, 'I': 2.0},
    #     'H': {'F': 3.0, 'I': 12.0, 'A': 15.0},
    #     'I': {'E': 2.0, 'H': 12.0},
    #     'J': {'K': 2.0},
    #     'K': {'J': 2.0}
    # }
    # # Граф без изолированных областей.
    # graph = {
    #     'A': {'B': 2.0, 'H': 15.0},
    #     'B': {'A': 2.0, 'C': 1.0, 'D': 5.0},
    #     'C': {'B': 1.0, 'D': 3.0, 'G': 1.0, 'F': 2.0},
    #     'D': {'B': 5.0, 'C': 3.0, 'F': 4.0, 'E': 6.0},
    #     'G': {'C': 1.0, 'F': 1.0},
    #     'F': {'C': 2.0, 'D': 4.0, 'G': 1.0, 'E': 7.0, 'H': 3.0},
    #     'E': {'D': 6.0, 'F': 7.0, 'I': 2.0},
    #     'H': {'F': 3.0, 'I': 12.0, 'A': 15.0},
    #     'I': {'E': 2.0, 'H': 12.0}
    # }
    # Граф без изолированных областей, изменил C-F/С-F с 2 на 3,
    # чтобы избежать неоднозначность путей для проверки.
    graph = {
        'A': {'B': 2.0, 'H': 15.0},
        'B': {'A': 2.0, 'C': 1.0, 'D': 5.0},
        'C': {'B': 1.0, 'D': 3.0, 'G': 1.0, 'F': 3.0},
        'D': {'B': 5.0, 'C': 3.0, 'F': 4.0, 'E': 6.0},
        'G': {'C': 1.0, 'F': 1.0},
        'F': {'C': 3.0, 'D': 4.0, 'G': 1.0, 'E': 7.0, 'H': 3.0},
        'E': {'D': 6.0, 'F': 7.0, 'I': 2.0},
        'H': {'F': 3.0, 'I': 12.0, 'A': 15.0},
        'I': {'E': 2.0, 'H': 12.0}
    }
    predecessors = dijkstra(graph, "A")
    print(predecessors)
    path = reconstruct_path(predecessors, "A", "H")
    print(path)


if __name__ == "__main__":
    main()
