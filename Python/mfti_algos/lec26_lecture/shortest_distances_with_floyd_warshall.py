# Алгоритм Флойда-Уоршелла — это алгоритм нахождения кратчайших путей
# между всеми парами вершин в взвешенном графе.
# Основное преимущество алгоритма заключается в его способности
# обрабатывать отрицательные веса рёбер, при условии отсутствия циклов
# отрицательного веса. Алгоритм Флойда-Уоршелла широко используется в
# областях, требующих решения задачи о кратчайших путях для всех пар
# вершин, например, в геоинформационных системах, сетевом анализе и
# планировании маршрутов.

# Сложность алгоритма
# Асимптотическая сложность алгоритма Флойда-Уоршелла составляет
# O(V^3), где V — количество вершин в графе. Это делает алгоритм хорошо
# подходящим для работы с плотными графами малого и среднего размера.
# Однако для очень больших графов или графов, где необходимо найти
# кратчайший путь только между небольшим числом пар вершин, могут быть
# предпочтительнее другие алгоритмы, такие как алгоритм Дейкстры или а
# лгоритм Беллмана-Форда.
def create_adj_matrix():
    # Задаем число вершин (n) и ребер (m) графа
    n, m = [int(x) for x in input().split()]
    # Создаем список вершин (V) и словарь для отслеживания индексов
    # каждой вершины (index)
    vertecies = []
    index = {}
    # Инициализация матрицы смежности размером N x N (N вершин)
    graph = [[0] * n for _ in range(n)]
    # Проходим через m ребер графа (вводим их и размещаем в матрице
    # смежности)
    for _ in range(m):
        # Считываем две вершины, соединенные ребром и вес
        v1, v2, weight = input().split()
        # Для каждой вершины в ребре
        for v in v1, v2:
            # Если вершина еще не добавлена, добавляем ее в список V и
            # в словарь index
            if v not in index:
                vertecies.append(v)
                index[v] = len(vertecies) - 1
        # Получаем индексы вершин в матрице смежности
        v1_idx = index[v1]
        v2_idx = index[v2]
        # Устанавливаем соответствующие значения в матрице смежности
        # с учетом веса (наличие ребра)
        weight = int(weight)
        graph[v1_idx][v2_idx] = weight
        graph[v2_idx][v1_idx] = weight
    return graph


def floyd_warshall(weights, n):
    """
    Алгоритм Флойда-Уоршелла для нахождения кратчайших путей
    между всеми парами вершин в графе.

    Args:
        weights (list of list of int/float): Матрица весов графа,
            где weights[i][j] - вес ребра от вершины i к вершине j.
            Если ребра нет, то weights[i][j] равно 0 (для этого
            алгоритма должно быть интерпретировано как бесконечность).
        n (int): Количество вершин в графе.

    Returns:
        list of list of float: Матрица кратчайших путей между всеми
        парами вершин. dist[i][j] содержит длину кратчайшего пути
        от i к j.
    """
    # Инициализация матрицы кратчайших путей из матрицы весов:
    # Если вес равен нулю и не является диагональным элементом (вершина
    # не ссылается сама на себя), то присваиваем бесконечность.
    # Иначе берем расстояние как вес из матрицы весов.
    # На диагональных элементах остаются нули.
    distances = [
        [float('inf') if weights[i][j] == 0 and i != j
         else weights[i][j] for j in range(n)] for i in range(n)
    ]
    # Основной цикл алгоритма. Перебираем все вершины как промежуточные
    # точки маршрута между каждой парой вершин.
    for k in range(n):
        # В этом цикле переменная 'k' представляет индекс промежуточной
        # вершины. Мы рассматриваем каждую вершину графа как возможную
        # промежуточную точку в пути между любыми двумя другими
        # вершинами. Это основа динамического программирования в
        # алгоритме Флойда-Уоршелла: мы постепенно находим кратчайшие
        # пути, используя уже найденные кратчайшие пути до и после
        # каждой промежуточной вершины.
        for i in range(n):
            # Цикл по 'i' перебирает все возможные начальные вершины
            # пути. 'i' — индекс начальной вершины пути. Мы будем искать
            # кратчайший путь от вершины 'i' ко всем другим вершинам,
            # учитывая текущую промежуточную вершину 'k'.
            for j in range(n):
                # Цикл по 'j' перебирает все возможные конечные вершины
                # пути. 'j' — индекс конечной вершины пути.
                # Таким образом, мы рассматриваем каждую возможную пару
                # вершин ('i', 'j') и пытаемся найти кратчайший
                # путь между ними через промежуточную вершину 'k'.

                # Обновляем длину кратчайшего пути между i и j через k,
                # если она короче текущей записанной длины.
                # distances[i][j] - Текущее значение кратчайшего пути
                # от 'i' до 'j'.
                # distances[i][k] + distances[k][j] - Сумма длин путей
                # от 'i' до 'k' и от 'k' до 'j'. Это значение
                # представляет собой длину пути от 'i' до 'j' через
                # промежуточную вершину 'k'.
                # Функция 'min' выбирает наименьшее из двух значений:
                # текущую длину кратчайшего пути между 'i' и 'j' и
                # потенциально более короткий путь через вершину 'k'.
                # Если путь через 'k' короче, значение 'distances[i][j]'
                # обновляется.
                distances[i][j] = min(
                    distances[i][j],
                    distances[i][k] + distances[k][j]
                )
    # В конце алгоритма в 'distances[i][j]' содержится длина кратчайшего
    # пути от вершины 'i' к вершине 'j' для всех пар вершин в графе.
    return distances


def main():
    # graph = create_adj_matrix()
    # print(graph)
    graph = [
        [0, 2, 0, 0, 0, 0, 0, 15, 0, 0, 0],
        [2, 0, 1, 5, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 3, 1, 2, 0, 0, 0, 0, 0],
        [0, 5, 3, 0, 0, 4, 6, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 2, 4, 1, 0, 7, 3, 0, 0, 0],
        [0, 0, 0, 6, 0, 7, 0, 0, 2, 0, 0],
        [15, 0, 0, 0, 0, 3, 0, 0, 12, 0, 0],
        [0, 0, 0, 0, 0, 0, 2, 12, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0]
    ]
    print(graph)
    distances = floyd_warshall(graph, 11)
    print(distances)


if __name__ == "__main__":
    main()
