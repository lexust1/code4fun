# "Наивный" алгоритм Дейсктры. Очередь не используется.
# - Обход начинается с первой вершины
# - Из вершины определяется путь до каждого соседа. Сосед до которого
# ближе всех, уходит в перечень посещенных. У остальных просто
# обновляются расстояния, если они лучше текущих.
# - Из этого соседа, мы опять ищем соседей и опять каратчайший путь.
# - Так до тех пор, пока не обойдем все вершины.
# Судя по тому, что я читал, это не самая наивная реализация, т.к.
# в текущей реализации поиск минимума ведется среди соседей текущей
# вершины. В самой наивной реализации мы на каждом шаге просматриваем
# расстояния до всех непосещенных вершин, что в "среднем" графе более
# затратно, чем проверить только соседей (в среднем 4-6 соседей вместо
# всех оставшихся вершин графа).

# Для более детального анализа асимптотики "наивного" алгоритма
# Дейкстры, рассмотрим его шаги подробнее:
#
# 1. Инициализация: На этом шаге создаются структуры данных для
# хранения информации о расстояниях от стартовой вершины до всех
# остальных (distances), множество посещённых вершин (visited),
# и словарь предшественников (predecessors). Этот шаг выполняется
# за O(V), где V — количество вершин, так как инициализация
# затрагивает каждую вершину.
#
# 2. Основной цикл алгоритма: Алгоритм повторяется, пока все
# вершины не будут посещены. На каждом шаге алгоритма выбирается
# вершина для посещения. В "наивной" реализации алгоритма Дейкстры
# для выбора следующей вершины для посещения требуется просмотреть
# все непосещённые вершины и выбрать среди них ту, которая имеет
# минимальное расстояние от стартовой вершины. Поиск вершины с
# минимальным расстоянием в "наивной" реализации выполняется за
# O(V), так как потенциально необходимо проверить каждую вершину.
#
# 3. Обновление расстояний: Для выбранной вершины алгоритм
# проверяет всех её соседей и обновляет расстояния до них, если
# найден более короткий путь. В худшем случае, если граф плотный,
# каждая вершина соединена с каждой, что означает, что для каждой
# вершины потенциально требуется проверить V-1 рёбер. Однако,
# так как алгоритм рассматривает только рёбра, исходящие из текущей
# вершины, общее количество рассмотренных рёбер за весь алгоритм
# будет O(E), где E — общее количество рёбер в графе.
#
# Таким образом, общая асимптотическая сложность алгоритма
# складывается из двух основных частей: выбора вершины с минимальным
# расстоянием и обновления расстояний. Выбор вершины выполняется
# V раз, каждый раз за O(V), что даёт O(V^2). Обновление
# расстояний для всех рёбер в худшем случае занимает O(E).
# Однако, поскольку этот шаг выполняется для каждой вершины,
# наиболее точная оценка будет O(V * E), предполагая, что
# каждая вершина может быть соединена со всеми остальными.
#
# В сумме, получаем общую асимптотическую сложность O(V^2 + V * E).
# Однако, учитывая, что E может быть в худшем случае до V^2 для
# плотных графов, выражение упрощается до O(V * E), что является
# общепринятой оценкой для "наивного" алгоритма Дейкстры
def create_adj_list():
    """
    Создает представление графа в виде списка смежности.

    Returns:
    graph: dict, представление графа в виде списка смежности
    """
    # Вводим количество вершин (n) и рёбер (m)
    n, m = [int(x) for x in input().split()]
    # Инициализируем граф
    graph = {}
    # Добавляем рёбра с весом
    for _ in range(m):
        v1, v2, weight = input().split()
        weight = float(weight)
        # Добавляем ребро в граф
        add_edge(graph, v1, v2, weight)
        # Добавляем обратное ребро в граф
        add_edge(graph, v2, v1, weight)
    return graph


def add_edge(graph, v1, v2, weight):
    """
    Добавляет ребро между двумя вершинами с заданным весом в граф.

    Args:
    graph (dict): Граф, в который будет добавлено ребро.
    v1: Первая вершина ребра.
    v2: Вторая вершина ребра.
    weight: Вес ребра.
    """
    if v1 not in graph:
        # Если вершина v1 отсутствует в графе, добавить её с словарём,
        # содержащим v2 как ключ и вес как значение
        graph[v1] = {v2: weight}
    else:
        # Если вершина v1 присутствует в графе, обновить словарь,
        # добавив v2 как ключ и вес как значение
        graph[v1][v2] = weight


def dijkstra(graph, start):
    """
    Реализация алгоритма Дейкстры для нахождения кратчайших путей от
    начальной вершины до всех остальных.

    Args:
    graph (dict): Граф, представленный в виде словаря смежности.
    start: Начальная вершина, с которой начинается поиск.

    Returns:
    predecessors: Список предшественников кратчайшего пути.
    """
    # Инициализация множества посещенных вершин
    visited = set()
    # Создание словаря для хранения кратчайших расстояний от start до
    # каждой вершины
    distances = {i: float("inf") for i in graph}
    # Создаем словарь предшественников
    predecessors = {i: None for i in graph}
    # Установка расстояния до начальной вершины равным 0
    distances[start] = 0
    # Добавление начальной вершины в множество посещенных
    visited.add(start)
    # Текущая вершина для рассмотрения
    vertex = start
    # Ведем рассмотрение, пока количество посещенных вершин не
    # сравняется с количеством вершин в графе.
    while len(visited) != len(graph):
        # Инициализация переменных для поиска ближайшего непосещенного
        # соседа
        min_distance = float("inf")
        candidate = None
        # Перебираем всех соседей текущей вершины.
        for neighbour in graph[vertex]:
            # Если соседа еще не посещали
            if neighbour not in visited:
                # Находим новое расстояние до текущего соседа
                new_distance = distances[vertex] + graph[vertex][neighbour]
                # Если это расстояние меньше расстояние, которое уже
                # хранится, обновляем его
                if new_distance < distances[neighbour]:
                    distances[neighbour] = new_distance
                # Если найденной расстояние (путь) до соседа оказывается
                # короче, чем все предыдущие, то сосед переходит в
                # кандидаты, как вершина кратчайшего пути.
                if new_distance < min_distance:
                    candidate = neighbour
                    min_distance = new_distance
        # Если кандидата нет, значит мы обошли все вершины текущей
        # компоненты, и пытаемся попасть в вершину из другой компоненты,
        # которая недостижима.
        if candidate is None:
            print("Все вершины данной компоненты посещены. "
                  "Остальные вершины из стартовой вершины недостижимы.")
            return predecessors
        # Либо мы добавляем финального кандидата на кратчайший путь и
        # сохряняем его предсшественника для востановления в будущем
        else:
            predecessors[candidate] = vertex
            visited.add(candidate)
            vertex = candidate
    # Возвращаем множество посещенных вершин
    return predecessors


# В лекции предлагается вариант восстановления через обратный счет,
# т.е. из длину пути до последнего узла мы вычитаем длину ребра до
# каждого соседа, смотрим совпадение и двигаемся вперед. Интресный
# поход. Вероятно, хорош, когда мы хотим сэкономить место под хранение
# предшественников. Но с предшественниками подход более прозрачный,
# меньше расчетов и просто список узлов вряд ли может занимать много
# места даже для больших графов. Поэтому сохраняем тот подход, который
# был и при BFS.
def reconstruct_path(predecessors, start, end):
    """
    Восстанавливает путь в графе от начальной до конечной вершины,
    используя предоставленный словарь предшественников.

    Args:
    predecessors (dict): Словарь, где ключи - это вершины, а значения -
    их предшественники. Получается в результате выполнения функции bfs.
    start (str): Начальная вершина пути.
    end (str): Конечная вершина пути.

    Returns:
    list: Список вершин, составляющих кратчайший путь от start до end.
          Возвращает "No path", если путь не существует.
    """
    # Начинаем с конечной вершины
    vertex = end
    path = []
    # Перемещаемся по предшественникам от конечной вершины к начальной
    while vertex != start:
        # Добавляем текущую вершину в путь
        path.append(vertex)
        # Получаем предшественника текущей вершины
        vertex = predecessors[vertex]
        # Если для вершины нет предшественника, путь не существует
        if vertex is None:
            return "No path"
    # Добавляем начальную вершину в путь как остаток пути
    path.append(start)
    # Возвращаем путь в правильном порядке от начальной до конечной
    # вершины, т.к. реконструкция идет с конца.
    return path[::-1]


def main():
    # graph = create_adj_list()
    # print(graph)
    # # Граф с изолированной областью
    # graph = {
    #     'A': {'B': 2.0, 'H': 15.0},
    #     'B': {'A': 2.0, 'C': 1.0, 'D': 5.0},
    #     'C': {'B': 1.0, 'D': 3.0, 'G': 1.0, 'F': 2.0},
    #     'D': {'B': 5.0, 'C': 3.0, 'F': 4.0, 'E': 6.0},
    #     'G': {'C': 1.0, 'F': 1.0},
    #     'F': {'C': 2.0, 'D': 4.0, 'G': 1.0, 'E': 7.0, 'H': 3.0},
    #     'E': {'D': 6.0, 'F': 7.0, 'I': 2.0},
    #     'H': {'F': 3.0, 'I': 12.0, 'A': 15.0},
    #     'I': {'E': 2.0, 'H': 12.0},
    #     'J': {'K': 2.0},
    #     'K': {'J': 2.0}
    # }
    # # Граф без изолированных областей.
    # graph = {
    #     'A': {'B': 2.0, 'H': 15.0},
    #     'B': {'A': 2.0, 'C': 1.0, 'D': 5.0},
    #     'C': {'B': 1.0, 'D': 3.0, 'G': 1.0, 'F': 2.0},
    #     'D': {'B': 5.0, 'C': 3.0, 'F': 4.0, 'E': 6.0},
    #     'G': {'C': 1.0, 'F': 1.0},
    #     'F': {'C': 2.0, 'D': 4.0, 'G': 1.0, 'E': 7.0, 'H': 3.0},
    #     'E': {'D': 6.0, 'F': 7.0, 'I': 2.0},
    #     'H': {'F': 3.0, 'I': 12.0, 'A': 15.0},
    #     'I': {'E': 2.0, 'H': 12.0}
    # }
    # Граф без изолированных областей, изменил C-F/С-F с 2 на 3,
    # чтобы избежать неоднозначность путей для проверки.
    graph = {
        'A': {'B': 2.0, 'H': 15.0},
        'B': {'A': 2.0, 'C': 1.0, 'D': 5.0},
        'C': {'B': 1.0, 'D': 3.0, 'G': 1.0, 'F': 3.0},
        'D': {'B': 5.0, 'C': 3.0, 'F': 4.0, 'E': 6.0},
        'G': {'C': 1.0, 'F': 1.0},
        'F': {'C': 3.0, 'D': 4.0, 'G': 1.0, 'E': 7.0, 'H': 3.0},
        'E': {'D': 6.0, 'F': 7.0, 'I': 2.0},
        'H': {'F': 3.0, 'I': 12.0, 'A': 15.0},
        'I': {'E': 2.0, 'H': 12.0}
    }
    predecessors = dijkstra(graph, "A")
    print(predecessors)
    path = reconstruct_path(predecessors, "A", "H")
    print(path)


if __name__ == "__main__":
    main()
