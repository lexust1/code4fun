# O(V+E)
from collections import deque


def create_adj_list():
    # Задаем число ребер (m) и вершин (n) графа
    n, m = [int(x) for x in input().split()]
    graph = {str(i): set() for i in range(n)}
    # Проходим по всем ребрам графа
    for _ in range(m):
        # Считываем вершины, соединенные ребром
        v1, v2 = input().split()
        # Т.к. граф не направленный, смотри в обоих направлениях
        for v, u in (v1, v2), (v2, v1):
            graph[v].add(u)
    return graph


def transform_graph(graph):
    """
    Преобразует исходный граф для поиска кратчайшего четного пути.

    Создает вспомогательный граф, где каждая вершина из исходного графа
    представлена двумя вершинами, отражающими четность пройденного пути
    до этой вершины. Каждое ребро из исходного графа превращается
    в два ребра в преобразованном графе, изменяя четность пути.

    Args:
        graph (dict): Исходный граф в виде словаря смежности,
            где ключи - это вершины, а значения - множества соседних
            вершин.

    Returns:
        dict: Преобразованный граф в виде словаря смежности, где
            каждая вершина представлена двумя состояниями
            (вершина, четность), а рёбра изменяют четность пути.

    Пример:
        Исходный граф:
            graph = {
                '1': {'2', '3'},
                '2': {'3'},
                '3': {'4'},
                '4': {}
            }

        Преобразованный граф:
            {
                ('1', 0): [('2', 1), ('3', 1)],
                ('1', 1): [('2', 0), ('3', 0)],
                ('2', 0): [('3', 1)],
                ('2', 1): [('3', 0)],
                ('3', 0): [('4', 1)],
                ('3', 1): [('4', 0)],
                ('4', 0): [],
                ('4', 1): []
            }
    """
    transformed_graph = {}
    for v in graph:
        # Создаем две вершины в преобразованном графе для каждой вершины
        # v исходного графа:
        # (v, 0) для четного пути и (v, 1) для нечетного пути.
        transformed_graph[(v, 0)] = []
        transformed_graph[(v, 1)] = []
        for u in graph[v]:
            # Для каждого соседа u вершины v добавляем два ребра:
            # одно ведет к вершине u с изменением четности на
            # противоположную, другое - к той же вершине u, но
            # сохраняет текущую четность.
            transformed_graph[(v, 0)].append((u, 1))
            transformed_graph[(v, 1)].append((u, 0))
    return transformed_graph


def bfs(graph, start, end):
    """
    Выполняет обход графа в ширину (Breadth-First Search, BFS) для
    поиска кратчайшего пути.

    Функция обходит граф, начиная с заданной начальной вершины, и ищет
    кратчайший путь до конечной вершины.

    В процессе обхода строится словарь предшественников, который можно
    использовать для восстановления пути.

    Args:
        graph (dict): Граф в виде словаря смежности, где ключи - это
            вершины, а значения - множества соседних вершин.
        start (tuple): Начальная вершина в формате (вершина, четность).
        end (tuple): Конечная вершина в формате (вершина, четность).

    Returns:
        dict: Словарь предшественников для каждой вершины. Если путь
        до конечной вершины не найден, возвращает пустой словарь.
    """
    # Инициализация множества посещенных вершин и очереди обхода
    visited = set()
    queue = deque([start])
    visited.add(start)
    # Инициализация словаря предшественников для всех вершин графа
    predecessors = {i: None for i in graph}
    # Основной цикл BFS
    while queue:
        # Извлечение текущей вершины из очереди
        vertex = queue.popleft()
        # Проверка на достижение конечной вершины
        if vertex == end:
            # Возвращаем словарь предшественников, если найден путь
            # до конечной вершины
            return predecessors
        # Перебор всех соседних вершин текущей вершины
        for neighbour in graph[vertex]:
            if neighbour not in visited:
                # Добавление непосещенного соседа в очередь и множество
                # посещенных вершин
                visited.add(neighbour)
                queue.append(neighbour)
                # Запись текущей вершины как предшественника соседа
                predecessors[neighbour] = vertex
    # Возвращение пустого словаря, если путь до конечной вершины не
    # найден
    return predecessors


def reconstruct_path(predecessors, start, end):
    """
    Восстанавливает путь в графе от начальной до конечной вершины,
    используя предоставленный словарь предшественников.

    Функция проходит от конечной вершины к начальной, используя словарь
    предшественников, чтобы определить, через какие вершины проходил
    кратчайший путь.

    Args:
        predecessors (dict): Словарь, где ключи - это вершины в формате
            (вершина, четность), а значения - их предшественники в пути.
        start (tuple): Начальная вершина пути в формате
            (вершина, четность).
        end (tuple): Конечная вершина пути в формате
            (вершина, четность).

    Returns:
        list: Список вершин (в исходном формате), составляющих
        кратчайший путь от start до end. Возвращает строку "No path",
        если путь не существует.

    Комментарии в коде:
        - Начинаем с конечной вершины и двигаемся назад к начальной,
        следуя предшественникам.
        - В процессе восстановления пути сохраняем только оригинальные
        вершины (без четности), чтобы получить путь в исходном графе.
    """
    path = []
    vertex = end
    # Восстановление пути от конечной вершины к начальной
    while vertex != start:
        # Добавляем оригинальную вершину (без четности) в путь
        # vertex[0] - оригинальная вершина
        path.append(vertex[0])
        # Переходим к предшественнику текущей вершины
        vertex = predecessors[vertex]
        # Если для вершины нет предшественника, путь не существует
        if vertex is None:
            return "No path"
    # Добавляем начальную вершину в путь
    # start[0] для согласованности с остальными вершинами
    path.append(start[0])
    # Возвращаем путь в обратном порядке (от начальной до конечной
    # вершины)
    return path[::-1]


def main():

    graph = {
        '0': {'12', '11', '1', '10'},
        '1': {'7', '0'},
        '2': set(),
        '3': {'11'},
        '4': {'10', '6'},
        '5': {'8', '13'},
        '6': {'4', '10'},
        '7': {'13', '1'},
        '8': {'12', '5'},
        '9': {'11'},
        '10': {'4', '0', '6'},
        '11': {'3', '14', '9', '0', '12'},
        '12': {'8', '11', '0'},
        '13': {'5', '7'},
        '14': {'11'}
    }
    print(graph, "\n")
    transformed_graph = transform_graph(graph)
    print(transformed_graph)
    # Начальная и конечная вершины в преобразованном графе
    start = ('9', 0)  # Стартовая вершина с четностью 0, т.е. четная
    end = ('8', 0)  # Конечная вершина с четностью 0, т.е. четная

    # Выполнение BFS в преобразованном графе
    predecessors = bfs(transformed_graph, start, end)

    # Восстановление пути
    path = reconstruct_path(predecessors, start, end)
    print(path)


if __name__ == "__main__":
    main()
