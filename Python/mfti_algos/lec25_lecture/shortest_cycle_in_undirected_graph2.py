# O(V*(V+E))
# По сравнению с предыдущей методикой, добавил критерий минимального
# расстояния. Это позволили делать востановление цикла только для
# реально самого короткого.
from collections import deque


def create_adj_list():
    # Задаем число ребер (m) и вершин (n) графа
    n, m = [int(x) for x in input().split()]
    graph = {str(i): set() for i in range(n)}
    # Проходим по всем ребрам графа
    for _ in range(m):
        # Считываем вершины, соединенные ребром
        v1, v2 = input().split()
        # Т.к. граф не направленный, смотри в обоих направлениях
        for v, u in (v1, v2), (v2, v1):
            graph[v].add(u)
    return graph


def bfs(graph, start):
    """
    Выполняет обход графа в ширину (Breadth-First Search, BFS) и
    обнаруживает циклы, исходящие из начальной вершины.

    Функция использует очередь для обработки узлов графа и множество для
    отслеживания посещенных узлов. При обнаружении соседней вершины,
    которая уже была посещена и не является непосредственным
    предшественником текущей вершины, фиксируется наличие цикла.
    Функция возвращает информацию о предшественниках в цикле, а также
    пару вершин, указывающих на наличие цикла.
    Если циклов, исходящих из начальной вершины, нет, возвращается
    False.

    Args:
    graph (dict): Граф, представленный в виде словаря, где ключи -
        это узлы, а значения - множества соседних узлов.
    start (str): Начальный узел, с которого начинается обход.

    Returns:
    tuple: (predecessors, end1, end2), где 'predecessors' - это словарь
        предшественников для каждой вершины, 'end1' и 'end2' -
        пара вершин, указывающая на наличие цикла.
        Если цикл не найден, возвращает False.
    """
    # Инициализируем множество для отслеживания посещенных узлов
    visited = set()
    # Создаем двустороннюю очередь (deque) и помещаем в нее начальный
    # узел.
    queue = deque([start])
    # Добавляем начальный узел в множество посещенных.
    visited.add(start)
    # Создаем словарь предшественников
    predecessors = {i: None for i in graph}
    # Создаем словарь расстояний с бесконечностями
    distances = {i: float('inf') for i in graph}
    # Расстояние до стартовой вершины
    distances[start] = 0
    # Продолжаем выполнять цикл, пока очередь не пуста
    while queue:
        # Извлекаем узел из начала очереди.
        vertex = queue.popleft()
        # Перебираем всех соседей текущего узла.
        for neighbour in graph[vertex]:
            # Если сосед еще не был посещен, добавляем его в множество
            # посещенных и в очередь.
            if neighbour not in visited:
                # Помечаем соседа как посещенный.
                visited.add(neighbour)
                # Добавляем соседа в очередь для дальнейшего обхода.
                queue.append(neighbour)
                # Сохраняем предшественника для соседа
                predecessors[neighbour] = vertex
                # Обновляем расстояние до соседа
                distances[neighbour] = distances[vertex] + 1
            # Если сосед уже был посещен и сосед не является
            # предшественником текущей вершины, это говорит о том, что
            # мы нашли цикл.
            elif neighbour in visited and neighbour != predecessors[vertex]:
                print("There is a cycle: ")
                # возвращаем лист предшественников и соседа с текущей
                # вершиной, которые указали, где образуется цикл.
                return predecessors, neighbour, vertex, distances[vertex] + 1
    # Если нет циклов
    return False


def find_shortest_cycle(graph):
    """
    Находит кратчайший цикл в графе, если таковой существует.

    Функция перебирает все вершины графа, используя алгоритм BFS,
    начиная с каждой вершины, для поиска циклов. Для каждого найденного
    цикла вычисляется его длина, и выбирается самый короткий.

    Args:
    graph (dict): Граф, представленный в виде словаря списков смежности.

    Returns:
    list: Список вершин, составляющих кратчайший цикл, или строку
        "No cycles", если циклов в графе не найдено.
    """
    # Инициализация длины цикла бесконечностью с целью поиска
    # минимального графа
    cycle_length = float("inf")
    # Список для хранения вершин текущего кратчайшего цикла
    cycle = []
    # Перебор всех вершин графа
    for vertex in graph:
        # Поиск цикла с помощью BFS
        candidate = bfs(graph, vertex)
        # Если цикл не найден и это первая итерация
        if not candidate and cycle == []:
            cycle = "No cycles"
            # print(f"No cycle when we start from vertex {vertex}")
        # Если цикл не найден, пропускаем итерацию
        elif not candidate:
            continue
        # Если найден цикл
        else:
            # Обновляем кратчайший цикл, если найденный короче текущего
            if candidate[3] < cycle_length:
                cycle_length = candidate[3]
                cycle = candidate
    # Возвращаем цикл
    return cycle


def reconstruct_cycle(predecessors, end1, end2):
    """
Восстанавливает цикл в графе, начиная с двух заданных вершин, используя
    предоставленный словарь предшественников.

    Эта функция предполагает, что end1 и end2 являются частью одного
    цикла. Она отслеживает предшественников от end2 до начала цикла,
    затем отслеживает предшественников от end1 до начала цикла, тем
    самым восстанавливая полный цикл.

    Args:
    predecessors (dict): Словарь, где ключи - это вершины, а значения -
        их предшественники. Этот словарь получается в результате
        выполнения функции bfs.
    end1 (str): Одна из вершин, участвующих в цикле.
    end2 (str): Другая вершина, участвующая в цикле.

    Returns:
    list: Список вершин, составляющих цикл. Порядок вершин соответствует
          порядку их прохождения в цикле, начиная с end1 и
          заканчивая end2.
    """
    # Начинаем с конечной вершины end2
    vertex = end2
    cycle = []
    # Востанавливаем 1-ю "полуветвь" цикла. Перемещаемся по
    # предшественникам от конечной вершины к начальной, пока не
    # достигнем вершины без предшественников - по сути, start(root),
    # откуда мы вообще и взяли этот цикл.
    while vertex is not None:
        # Добавляем текущую вершину в путь
        cycle.append(vertex)
        # Получаем предшественника текущей вершины
        vertex = predecessors[vertex]
    # Переворачиваем первую полуветвь.
    cycle = cycle[::-1]
    # Начинаем с начальное вершины end1 (делаем то же, что и выше, но
    # с другого конца и без переворачивания, чтобы выглядело как
    # продолжение вершин 1-й полуветви).
    vertex = end1
    # Востанавливаем 2-ю "полуветвь" цикла. Перемещаемся по
    # предшественникам от конечной вершины к начальной, пока не
    # достигнем вершины без предшественников - по сути, start(root),
    # откуда мы вообще и взяли этот цикл.
    while vertex is not None:
        # Добавляем текущую вершину в путь
        cycle.append(vertex)
        # Получаем предшественника текущей вершины
        vertex = predecessors[vertex]
    # возвращаем цикл
    return cycle


def main():
    # print(create_adj_list())
    # Связный граф без изолированных частей.
    # graph = {
    #     '0': {'12', '11', '1', '10'},
    #     '1': {'7', '0'},
    #     '2': {'6'},
    #     '3': {'11'},
    #     '4': {'10', '6'},
    #     '5': {'8', '13'},
    #     '6': {'4', '2', '10'},
    #     '7': {'13', '1'},
    #     '8': {'12', '5'},
    #     '9': {'11'},
    #     '10': {'4', '0', '6'},
    #     '11': {'3', '14', '9', '0', '12'},
    #     '12': {'8', '11', '0'},
    #     '13': {'5', '7'},
    #     '14': {'11'}
    # }
    # # Граф с изоляцей вершины 2
    # graph = {
    #     '0': {'12', '11', '1', '10'},
    #     '1': {'7', '0'},
    #     '2': set(),
    #     '3': {'11'},
    #     '4': {'10', '6'},
    #     '5': {'8', '13'},
    #     '6': {'4', '10'},
    #     '7': {'13', '1'},
    #     '8': {'12', '5'},
    #     '9': {'11'},
    #     '10': {'4', '0', '6'},
    #     '11': {'3', '14', '9', '0', '12'},
    #     '12': {'8', '11', '0'},
    #     '13': {'5', '7'},
    #     '14': {'11'}
    # }
    # Граф с изоляцей вершины 2 и дополнительным хвостом из вершины 2
    # с узлами 15, 16, 17
    graph = {
        '0': {'12', '11', '1', '10'},
        '1': {'7', '0'},
        '2': {'15'},
        '3': {'11'},
        '4': {'10', '6'},
        '5': {'8', '13'},
        '6': {'4', '10'},
        '7': {'13', '1'},
        '8': {'12', '5'},
        '9': {'11'},
        '10': {'4', '0', '6'},
        '11': {'3', '14', '9', '0', '12'},
        '12': {'8', '11', '0'},
        '13': {'5', '7'},
        '14': {'11'},
        '15': {'2', '16'},
        '16': {'15', '17'},
        '17': {'16'}
    }
    # # Граф с изоляцей вершины 2 и дополнительным хвостом из вершины 2
    # # с узлами 15, 16, 17. При этом разорваны все циклы засчет удаления
    # # ребер 10-4, 11-12, 7-13
    # graph = {
    #     '0': {'12', '11', '1', '10'},
    #     '1': {'7', '0'},
    #     '2': {'15'},
    #     '3': {'11'},
    #     '4': {'6'},
    #     '5': {'8', '13'},
    #     '6': {'4', '10'},
    #     '7': {'1'},
    #     '8': {'12', '5'},
    #     '9': {'11'},
    #     '10': {'0', '6'},
    #     '11': {'3', '14', '9', '0'},
    #     '12': {'8', '0'},
    #     '13': {'5'},
    #     '14': {'11'},
    #     '15': {'2', '16'},
    #     '16': {'15', '17'},
    #     '17': {'16'}
    # }

    # # Граф с одним большим циклом
    # graph = {
    #     '0': {'1', '4'},
    #     '1': {'0', '2'},
    #     '2': {'1', '3'},
    #     '3': {'4', '2'},
    #     '4': {'3', '0'},
    # }
    cycle = find_shortest_cycle(graph)
    print(cycle)
    path = reconstruct_cycle(*cycle[:-1])
    print(path)
    # print(bfs(graph, "0"))


if __name__ == "__main__":
    main()
