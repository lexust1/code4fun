# Сдать решение задачи F-Кузнечик-брокер
#
# Кузнечик находится на Бирже, которая является числовой прямой, в
# клетке №1 и собирается заработать денег. В каждой клетке числовой
# прямой, которую он посещает, он вынужден заключить сделку со всеми
# имеющимися средствами. При этом он может получить как прибыль, так и
# убыток. Прибыльность каждой клетки задана процентами со знаком.
# Если знак положительный — сделка увеличивает сумму денег Кузнечика на
# указанный процент от его текущей суммы. Если отрицательный — сделка
# уменьшает сумму денег Кузнечика на указанный процент. В самой
# клетке №1 никакой сделки не заключается.
#
# Вывести на экран путь, максимизирующий сумму, которую сможет
# заработать Кузнечик на бирже, если он может совершать прыжки на
# клетку с номером +2 и +3 от текущей, но не может прыгнуть на
# соседнюю клетку.
#
# Обратите внимание, что Кузнечик не обязан останавливаться в точке
# последней возможной сделки! Более того, если совершение сделок
# окажется убыточным, Кузнечик имеет право остаться в клетке №1 с
# исходным капиталом.
#
# Формат входных данных
# В первой строке записано целое число — стартовый капитал Кузнечика.
# Во второй строке записаны целые числа — проценты со знаком + или -.
# Доходность не превышает 1000%, а убыточность -100%. Отрицательный
# баланс у Кузнечика недопустим. Максимальный номер клетки задаётся
# количеством чисел в строке ввода.
#
# Формат выходных данных
# Клетки, по которым должен пройти Кузнечик, чтобы получить
# максимальную выгоду.
#
# Примеры
# Ввод	            Вывод
# 10                  1 3
# 0 0 10 -10
#
#
# Ввод	            Вывод
# 10                  1 3 5
# 0 0 -10 10 1000
#
#
# Ввод	            Вывод
# 10                  1
# 0 0 -10 -10 -10
#
# Детализация для граничных условий.
# 0   1 2   3  4  5  6
# 0 + 0 0 - некуда прыгать
# 0 + 0 0  10 - один вариант для прыжка +2, есть профит
# 0 + 0 0 -10 - один вариант для прыжка +2, убыток - не прыгаем
# 0 + 0 0  10 -10 - можно прыгнуть как +2 , так +3.  +2 - профит. +3 - убыток. Прыгаем в +2
# 0 + 0 0 -10  10 - можно прыгнуть как +2, так +3. +2 - убыток. + 3 - профит. Прыгаем в +3
# 0 + 0 0 -10 -10 - можно прыгнать как +2, так +3. Будет убыток, не прыгаем.
# 0 + 0 0  10  10 - неважно куда прыгать, профит одинаковый.


def create_input_data():
    print("Input the data: ")
    arr = []
    while True:
        inp = input()
        if inp == " ":
            break
        arr.append(inp)
    return arr


def calculate_max_profit_with_path(arr):
    """
        Вычисляет максимальную прибыль и оптимальный путь для кузнечика на бирже.

        Args:
            arr (list): Список, содержащий начальный капитал и проценты прибыли/убытка.

        Returns:
            tuple: Первый элемент - список с максимальной прибылью на каждой клетке,
                   второй элемент - список с предшествующей клеткой для каждого шага.
    """
    # Преобразование начального капитала кузнечика из строки в число
    init_money = int(arr[0])
    # Добавление нулевого процента прибыли для начальной клетки для удобства расчетов
    arr[1] = "0 " + arr[1]
    # Преобразование строки с процентами прибыли/убытка в список целых чисел
    percents = [int(el) for el in arr[1].split()]
    # Определение общего количества клеток
    n = len(percents)
    # Обработка специальных случаев с малым количеством клеток
    if n == 3:
        # Случай, когда нет клеток для прыжков
        return "Некуда прыгать."
    elif n == 4:
        # Случай, когда есть только одна клетка для прыжка
        if percents[3] < 0:
            # Не прыгаем, если в единственной доступной клетке убыток
            return [float("-inf"), init_money], [1]
        else:
            # Прыгаем, если на единственной доступной клетке прибыль
            return [float("-inf"), init_money, (1 + percents[3] / 100) * init_money], [1, 3]
    elif n == 5:
        # Случай, когда есть две клетки для прыжка
        # Рассчитываем прибыль для каждой из них
        profit_2 = (1 + percents[3] / 100) * init_money
        profit_3 = (1 + percents[4] / 100) * init_money
        # Выбираем клетку с максимальной прибылью
        if profit_2 > profit_3:
            return [float("-inf"), init_money, profit_2], [1, 3]
        else:
            return [float("-inf"), init_money, profit_2, profit_3], [1, 4]
    # Инициализация списка с доходами на каждой клетке и предшествующими клетками
    income = [float("-inf"), init_money, float("-inf"), (1 + percents[3] / 100) * init_money] + [0] * (n - 4)
    prev = [0] * (n)
    # Рассчитываем максимальную прибыль для каждой клетки, начиная с четвертой
    for i in range(4, n):
        # Рассчитываем потенциальную прибыль от прыжка на 2 и 3 клетки вперед
        profit_2 = income[i - 2] * (1 + percents[i] / 100)
        profit_3 = income[i - 3] * (1 + percents[i] / 100)
        # Выбираем вариант с максимальной прибылью
        if profit_2 > profit_3:
            income[i] = profit_2
            prev[i] = i - 2
        else:
            income[i] = profit_3
            prev[i] = i - 3
    # Возвращаем список с максимальной прибылью на каждой клетке и список предшествующих клеток
    return income, prev


def reconstruct_path(income, prev):
    """
    Восстанавливает оптимальный путь для кузнечика на бирже, исходя из максимальной прибыли.

    Args:
        income (list): Список, содержащий максимальную прибыль на каждой клетке.
        prev (list): Список, указывающий предыдущую клетку, с которой кузнечик пришел на текущую клетку.

    Returns:
        tuple: Возвращает максимальную прибыль и список клеток, образующих оптимальный путь.
    """
    # Находим максимальную прибыль из всех клеток
    max_income = max(income)
    # Проверяем, превышает ли максимальная прибыль начальный капитал
    if max_income <= income[1]:
        # Если прибыль не увеличивается, остаемся на первой клетке
        return "Нет сделок, которые позволяют заработать. Остаемся на первой клетке."
    # Находим индекс клетки с максимальной прибылью
    max_idx = income.index(max_income)
    # Обрезаем массив prev до клетки с максимальной прибылью
    prev = prev[:max_idx + 1]
    # Инициализация списка для восстановления пути
    path = []
    # Начинаем с клетки с максимальной прибылью и возвращаемся назад, следуя по массиву prev
    n = len(prev) - 1
    while n > 0:
        path.append(n)
        n = prev[n]
    # Добавляем начальную клетку в путь
    path.append(1)
    # Разворачиваем путь для правильного порядка
    return max_income, path[::-1]


def main():
    # arr = ["10", "0 0 10 -10"]
    # arr = ["10", "0 0 -10 10 1000"]
    # arr = ["10", "0 0 -10 -10 -10"]
    arr = ["10", "0 0 -10 10 1000 -20 -20 -20 -20"]
    income, prev = calculate_max_profit_with_path(arr)
    print(income, prev)
    if len(prev) > 5:
        print(reconstruct_path(income, prev))


if __name__ == "__main__":
    main()
