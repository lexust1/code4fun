# Сдать решение задачи D-Игрушечный лабиринт
#
# Игрушечный лабиринт представляет собой прозрачную плоскую
# прямоугольную коробку, внутри которой есть препятствия и перемещается
# шарик. Лабиринт можно наклонять влево, вправо, к себе или от себя,
# после каждого наклона шарик перемещается в заданном направлении до
# ближайшего препятствия или до стенки лабиринта, после чего
# останавливается. Целью игры является загнать шарик в одно из
# специальных отверстий – выходов. Шарик проваливается в отверстие,
# если оно встречается на его пути (шарик не обязан останавливаться
# в отверстии).
#
# Первоначально шарик находится в левом верхнем углу лабиринта.
# Гарантируется, что решение существует и левый верхний угол не занят
# препятствием или отверстием.
#
# Формат входных данных
# В первой строке входного файла записаны числа N и M – размеры
# лабиринта (целые положительные числа, не превышающие 100). Затем идет
# N строк по M чисел в каждой – описание лабиринта. Число 0 в описании
# означает свободное место, число 1 – препятствие, число 2 – отверстие.
#
# Формат выходных данных
# Выведите единственное число – минимальное количество наклонов,
# которые необходимо сделать, чтобы шарик покинул лабиринт через одно
# из отверстий.
#
# Примеры
# Ввод
# 4 5
# 0 0 0 0 1
# 0 1 1 0 2
# 0 2 1 0 0
# 0 0 1 0 0
# Вывод
# 3
#
# Ввод
# 2 2
# 0 0
# 0 2
# Вывод
# 2
from collections import deque


def create_adj_list():
    """
    Создает список смежности для представления графа лабиринта и
    сохраняет позиции отверстий.

    Returns:
    graph (dict): список смежности, представляющий граф лабиринта
    holes (set): множество позиций отверстий в лабиринте
    """
    # Задаем число строк (n) и столбцов (m) в лабиринте
    n, m = [int(x) for x in input().split()]
    # Возможные "ходы"
    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    # Создаем лист листов из стрингов для обработки
    rectangle = []
    for _ in range(n):
        rectangle.append(input().split())
    # Инициализируем множество под хранение отверстий
    holes = set()
    # Инициализируем граф
    graph = {}
    # Проходимся через каждую ячейку заданного графа.
    for i in range(n):
        for j in range(m):
            # Если ячейка проходима
            if rectangle[i][j] == "0" or rectangle[i][j] == "2":
                # Создаем вершину в графе с пустым множеством
                vertex = f"{i + 1}{j + 1}"
                graph[vertex] = set()
                # Из каждой ячейки рассматриваем допустимые ходы к
                # соседям
                for dx, dy in moves:
                    x, y = i, j
                    # Перемещаемся до столкновения с препятствием или
                    # краем лабиринта
                    while (0 <= x + dx < n and
                           0 <= y + dy < m and
                           rectangle[x + dx][y + dy] != "1"):
                        x += dx
                        y += dy
                        # Если на пути встречается отверстие
                        if rectangle[x][y] == "2":
                            holes.add(f"{x + 1}{y + 1}")
                            # Прерываем цикл, если достигли отверстия
                            break
                    # Добавляем в граф только если новая позиция
                    # отличается от начальной
                    if (x, y) != (i, j):
                        neighbour = f"{x + 1}{y + 1}"
                        graph[vertex].add(neighbour)
    return graph, holes


def bfs(graph, start, end):
    """
    Выполняет обход графа в ширину (Breadth-First Search, BFS) и
    вычисляет расстояние от начальной вершины до конечной.

    Функция использует очередь для обработки узлов графа. Каждый узел
    сначала проверяется на наличие в множестве посещенных узлов. Если
    узел не посещен, он добавляется в множество посещенных и в очередь.
    При этом обновляется расстояние от начального узла до текущего.
    Обход прекращается, как только найдена конечная вершина, и
    возвращается расстояние до неё.
    Если конечная вершина недостижима, возвращает float('inf').

    Args:
    graph (dict): Граф, представленный в виде словаря, где ключи -
        это узлы, а значения - множества соседних узлов.
    start (str): Начальный узел, с которого начинается обход.
    end (str): Конечный узел, до которого нужно вычислить расстояние.

    Returns:
    int: Расстояние от начальной до конечной вершины, если оно существует,
         иначе float('inf').
    """
    # Инициализируем множество для отслеживания посещенных узлов
    visited = set()
    # Создаем двустороннюю очередь (deque) и помещаем в нее начальный
    # узел.
    queue = deque([start])
    # Добавляем начальный узел в множество посещенных.
    visited.add(start)
    # Создаем словарь расстояний с бесконечностями
    distances = {i: float('inf') for i in graph}
    # Расстояние до стартовой вершины
    distances[start] = 0
    # Продолжаем выполнять цикл, пока очередь не пуста
    while queue:
        # Извлекаем узел из начала очереди.
        vertex = queue.popleft()
        # Проверяем, достигли ли искомой вершины, чтобы не ходить через
        # оставшийся граф. Своеобразная оптимизация.
        if vertex == end:
            return distances[end]
        # # Выводим узел, на каждом шаге. Но оформляем все в одну строку.
        # print(str(vertex), end=" ")
        # Перебираем всех соседей текущего узла.
        for neighbour in graph[vertex]:
            # Если сосед еще не был посещен, добавляем его в множество
            # посещенных и в очередь.
            if neighbour not in visited:
                # Помечаем соседа как посещенный.
                visited.add(neighbour)
                # Добавляем соседа в очередь для дальнейшего обхода.
                queue.append(neighbour)
                # Обновляем расстояние до соседа
                distances[neighbour] = distances[vertex] + 1
    return distances[end]


def main():
    # graph, holes = create_adj_list()
    # print(graph)
    # print(holes)
    # Case 1
    graph = {
        '11': {'14', '41'},
        '12': {'14', '11'},
        '13': {'14', '11'},
        '14': {'44', '11'},
        '21': {'41', '11'},
        '24': {'44', '14', '25'},
        '25': {'24', '45'},
        '31': {'11', '32', '41'},
        '32': {'31', '42'},
        '34': {'44', '14', '35'},
        '35': {'45', '34', '25'},
        '41': {'11', '42'},
        '42': {'41', '32'},
        '44': {'14', '45'},
        '45': {'44', '25'}
    }
    holes = {'32', '25'}
    # # Case 2
    # graph = {
    #     '11': {'12', '21'},
    #     '12': {'22', '11'},
    #     '21': {'22', '11'},
    #     '22': {'12', '21'}
    # }
    # holes = {'22'}

    min_distance = float("inf")
    for hole in holes:
        distance = bfs(graph, "11", hole)
        if distance < min_distance:
            min_distance = distance
    print(min_distance)


if __name__ == "__main__":
    main()
