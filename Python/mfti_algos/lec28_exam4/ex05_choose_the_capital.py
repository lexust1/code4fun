# Сдать решение задачи E-Нахождение вершины-столицы
#
# В некотором государстве некотрые города соединены дорогами.
# Жители этого государства просят вас помочь им с выбором столицы:
# требуется, чтобы сумма расстояний от столицы до каждого из остальных
# городов была минимальна.
#
# Для вашего удобства города уже пронумерованы от 0 до n-1 .
#
# Формат входных данных
# На вход программе в первой строке подается два числа через пробел:
# n и m . n (2 <= n <= 100) - число городов, m (1 <= m <= 500) -
# число дорог. В следующих m строках задаются дороги, по три числа в
# каждой строке - номера соединенных городов и длина дороги.
#
# Формат выходных данных
# Выведите номер столицы. Если возможно несколько варинтов, выведете
# любой.
#
# Примеры
# Ввод
# 4 3
# 0 1 34
# 2 1 7
# 3 2 85
# Вывод
# 1
#
# Ввод
# 8 9
# 6 3 91
# 0 4 92
# 6 7 56
# 1 6 99
# 1 5 66
# 0 2 64
# 3 5 75
# 0 1 33
# 0 3 19
# Вывод
# 0
def create_adj_matrix():
    # Задаем число вершин (n) и ребер (m) графа
    n, m = [int(x) for x in input().split()]
    # Создаем список вершин (V) и словарь для отслеживания индексов
    # каждой вершины (index)
    vertecies = []
    index = {}
    # Инициализация матрицы смежности размером N x N (N вершин)
    graph = [[0] * n for _ in range(n)]
    # Проходим через m ребер графа (вводим их и размещаем в матрице
    # смежности)
    for _ in range(m):
        # Считываем две вершины, соединенные ребром и вес
        v1, v2, weight = input().split()
        # Для каждой вершины в ребре
        for v in v1, v2:
            # Если вершина еще не добавлена, добавляем ее в список V и
            # в словарь index
            if v not in index:
                vertecies.append(v)
                index[v] = len(vertecies) - 1
        # Получаем индексы вершин в матрице смежности
        v1_idx = index[v1]
        v2_idx = index[v2]
        # Устанавливаем соответствующие значения в матрице смежности
        # с учетом веса (наличие ребра)
        weight = int(weight)
        graph[v1_idx][v2_idx] = weight
        graph[v2_idx][v1_idx] = weight
    return graph, n


def floyd_warshall(weights, n):
    """
    Алгоритм Флойда-Уоршелла для нахождения кратчайших путей
    между всеми парами вершин в графе.

    Args:
        weights (list of list of int/float): Матрица весов графа,
            где weights[i][j] - вес ребра от вершины i к вершине j.
            Если ребра нет, то weights[i][j] равно 0 (для этого
            алгоритма должно быть интерпретировано как бесконечность).
        n (int): Количество вершин в графе.

    Returns:
        list of list of float: Матрица кратчайших путей между всеми
        парами вершин. dist[i][j] содержит длину кратчайшего пути
        от i к j.
    """
    # Инициализация матрицы кратчайших путей из матрицы весов:
    # Если вес равен нулю и не является диагональным элементом (вершина
    # не ссылается сама на себя), то присваиваем бесконечность.
    # Иначе берем расстояние как вес из матрицы весов.
    # На диагональных элементах остаются нули.
    distances = [
        [float('inf') if weights[i][j] == 0 and i != j
         else weights[i][j] for j in range(n)] for i in range(n)
    ]
    # Основной цикл алгоритма. Перебираем все вершины как промежуточные
    # точки маршрута между каждой парой вершин.
    for k in range(n):
        # В этом цикле переменная 'k' представляет индекс промежуточной
        # вершины. Мы рассматриваем каждую вершину графа как возможную
        # промежуточную точку в пути между любыми двумя другими
        # вершинами. Это основа динамического программирования в
        # алгоритме Флойда-Уоршелла: мы постепенно находим кратчайшие
        # пути, используя уже найденные кратчайшие пути до и после
        # каждой промежуточной вершины.
        for i in range(n):
            # Цикл по 'i' перебирает все возможные начальные вершины
            # пути. 'i' — индекс начальной вершины пути. Мы будем искать
            # кратчайший путь от вершины 'i' ко всем другим вершинам,
            # учитывая текущую промежуточную вершину 'k'.
            for j in range(n):
                # Цикл по 'j' перебирает все возможные конечные вершины
                # пути. 'j' — индекс конечной вершины пути.
                # Таким образом, мы рассматриваем каждую возможную пару
                # вершин ('i', 'j') и пытаемся найти кратчайший
                # путь между ними через промежуточную вершину 'k'.

                # Обновляем длину кратчайшего пути между i и j через k,
                # если она короче текущей записанной длины.
                # distances[i][j] - Текущее значение кратчайшего пути
                # от 'i' до 'j'.
                # distances[i][k] + distances[k][j] - Сумма длин путей
                # от 'i' до 'k' и от 'k' до 'j'. Это значение
                # представляет собой длину пути от 'i' до 'j' через
                # промежуточную вершину 'k'.
                # Функция 'min' выбирает наименьшее из двух значений:
                # текущую длину кратчайшего пути между 'i' и 'j' и
                # потенциально более короткий путь через вершину 'k'.
                # Если путь через 'k' короче, значение 'distances[i][j]'
                # обновляется.
                distances[i][j] = min(
                    distances[i][j],
                    distances[i][k] + distances[k][j]
                )
    # В конце алгоритма в 'distances[i][j]' содержится длина кратчайшего
    # пути от вершины 'i' к вершине 'j' для всех пар вершин в графе.
    return distances


def choose_the_capital(distances):
    """
    Выбирает столицу на основе общего расстояния до всех других городов.

    Args:
    distances (list): Список списков, представляющих расстояния между
    городами.

    Returns:
    int: Индекс города-столицы в списке distances.
    """
    # Инициализация минимального общего расстояния бесконечностью
    min_total = float("inf")
    # Инициализация счетчика городов и индекса столицы
    cnt = 0
    capital = None
    for row in distances:
        # Вычисление общего расстояния до всех других городов
        total_distance = sum(row)
        # Обновление столицы, если общее расстояние меньше текущего
        # минимума
        if total_distance < min_total:
            capital = cnt
            min_total = total_distance
        # Увеличение счетчика городов
        cnt += 1
    return capital


def main():
    # graph, n = create_adj_matrix()
    # print(graph)
    # # Case 1
    # n = 4
    # graph = [
    #     [0, 34, 0, 0],
    #     [34, 0, 7, 0],
    #     [0, 7, 0, 85],
    #     [0, 0, 85, 0]
    # ]
    # Case 2
    n = 8
    graph = [
        [0, 91, 0, 0, 56, 99, 0, 0],
        [91, 0, 19, 0, 0, 0, 75, 0],
        [0, 19, 0, 92, 0, 33, 0, 64],
        [0, 0, 92, 0, 0, 0, 0, 0],
        [56, 0, 0, 0, 0, 0, 0, 0],
        [99, 0, 33, 0, 0, 0, 66, 0],
        [0, 75, 0, 0, 0, 66, 0, 0],
        [0, 0, 64, 0, 0, 0, 0, 0]
    ]
    distances = floyd_warshall(graph, n)
    # print(distances)
    capital = choose_the_capital(distances)
    print(capital)


if __name__ == "__main__":
    main()
