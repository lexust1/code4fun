# Сдать решение задачи A-Шашку - в дамки
#
# На шахматной доске (8x8) стоит одна белая шашка. Сколькими способами
# она может пройти в дамки? Белая шашка ходит по диагонали. на одну
# клетку вверх-вправо или вверх-влево. Шашка проходит в дамки, если
# попадает на верхнюю горизонталь.
#
# Формат входных данных
# Вводятся два числа от 1 до 8: номер номер столбца (считая слева) и
# строки (считая снизу), где изначально стоит шашка.
#
# Формат выходных данных
# Вывести одно число - количество путей в дамки.
#
# Примеры
# Ввод	Вывод
# 3 7     2
#
#
# Ввод	Вывод
# 1 8     1
#
#
# Ввод	Вывод
# 3 6     4
#
def create_input_data():
    col, row = input().split()
    return int(col), int(row)


def count_ways_to_promotion(col, row):
    # Инициализируем таблицу динамического программирования размером
    # 9x9. Здесь dp[r][c] будет хранить количество способов добраться
    # до клетки (r, c) из начальной позиции. Используем размер 9x9,
    # чтобы упростить индексацию, начиная с 1 (по аналогии с шахматной
    # доской), и избежать необходимости обрабатывать граничные условия
    # для краёв доски.
    dp = [[0 for _ in range(9)] for _ in range(9)]
    # Устанавливаем базовый случай динамического программирования:
    # если шашка достигает верхней горизонтали (8-я строка шахматной
    # доски), существует ровно один способ добраться до этой позиции —
    # она уже там. Это утверждение верно для любой позиции в верхней
    # строке, так как мы рассматриваем только момент достижения
    # этой строки, а не конкретные ходы внутри неё.
    for c in range(1, 9):
        dp[8][c] = 1
    # Основной цикл для заполнения таблицы dp, начиная с 7-й строки и
    # двигаясь вниз к 1-й строке. Это направление выбрано потому, что
    # мы рассчитываем количество путей от целевой строки (где шашка
    # становится дамкой) к начальной позиции шашки, учитывая возможные
    # ходы.
    for r in range(7, 0, -1):
        # Проходим по всем столбцам в строке.
        for c in range(1, 9):
            # Если шашка может идти вверх-влево (не находится на левом
            # краю доски), увеличиваем количество способов добраться до
            # текущей клетки (r, c) на количество способов добраться
            # до клетки слева-внизу от неё (r+1, c-1).
            if c > 1:
                dp[r][c] += dp[r + 1][c - 1]
            # Если шашка может идти вверх-вправо (не находится на
            # правом краю доски), увеличиваем количество способов
            # добраться до текущей клетки (r, c) на количество способов
            # добраться до клетки справа-внизу от неё (r+1, c+1).
            if c < 8:
                dp[r][c] += dp[r + 1][c + 1]
    # Возвращаем количество способов добраться до заданной начальной
    # позиции (row, col) из любой позиции в нижней строке, что было
    # рассчитано и сохранено в таблице dp.
    return dp[row][col]


def main():
    # col, row = create_input_data()
    # print(count_ways_to_promotion(col, row))
    print(count_ways_to_promotion(3, 7))
    print(count_ways_to_promotion(1, 8))
    print(count_ways_to_promotion(3, 6))


if __name__ == "__main__":
    main()
