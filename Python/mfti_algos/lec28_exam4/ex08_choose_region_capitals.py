# Сдать решение задачи H-Реформа округов
#
# Правитель графландии решил провести реформу административных округов
# в своем государстве. А именно ему хочется, чтобы расстояние от города
# до главного города его округа не превышало расстояния от данного
# города до главных городов других округов. Главные города правитель
# уже выбрал, вам остается всего лишь разбить остальные города по
# округам. Если есть несколько вариантов расстановки - подойдет любой.
# Если не справитесь, вам отрубят голову.
#
# Формат входных данных
# На вход программе в первой строке подается несколько (не менее трех)
# чисел через пробел: n , m , a1 , a2 , ... Число n (2 <= n <= 1000) -
# число городов, m (1 <= m <= 100000) - число дорог ai - номера главных
# городов. В следующих m` строках задаются дороги, по три числа в
# каждой строке - номера соединенных городов и длина дороги. Города
# пронумерованы с 0.
#
# Формат выходных данных
# Для каждого города в отдельной стоке выведите главный город его
# округа. Для 0го города - в первой строке, для 1го - во второй, ...
# Если для данного города не достижим ни один из главных - выведите в
# соответствующей строке -1.
#
# Примеры
# Ввод
# 4 3 0 1
# 0 1 34
# 2 1 7
# 3 2 85
# Вывод
# 0
# 1
# 1
# 1
#
# Ввод
# 6 5 0 1
# 2 1 24
# 4 2 1
# 1 0 78
# 5 1 51
# 0 3 19
# Вывод
# 0
# 1
# 1
# 0
# 1
# 1
# Выводы решил сохранить в другом более наглядном виде, в виде словаря,
# где для каждого города прописано, что столица, а не просто перечень
# непонятных цифр.
import heapq


def create_adj_list():
    """
    Создает представление графа в виде списка смежности.

    Returns:
    graph: dict, представление графа в виде списка смежности
    """
    # Вводим количество вершин (n) и рёбер (m)
    inp = input().split()
    n, m = int(inp[0]), int(inp[1])
    starts = inp[2:]
    # Инициализируем граф
    graph = {}
    # Добавляем рёбра с весом
    for _ in range(m):
        v1, v2, weight = input().split()
        weight = float(weight)
        # Добавляем ребро в граф
        add_edge(graph, v1, v2, weight)
        # Добавляем обратное ребро в граф
        add_edge(graph, v2, v1, weight)
    return graph, starts


def add_edge(graph, v1, v2, weight):
    """
    Добавляет ребро между двумя вершинами с заданным весом в граф.

    Args:
    graph (dict): Граф, в который будет добавлено ребро.
    v1: Первая вершина ребра.
    v2: Вторая вершина ребра.
    weight: Вес ребра.
    """
    if v1 not in graph:
        # Если вершина v1 отсутствует в графе, добавить её с словарём,
        # содержащим v2 как ключ и вес как значение
        graph[v1] = {v2: weight}
    else:
        # Если вершина v1 присутствует в графе, обновить словарь,
        # добавив v2 как ключ и вес как значение
        graph[v1][v2] = weight


def dijkstra(graph, start):
    """
    Реализация алгоритма Дейкстры для нахождения кратчайших путей от
    начальной вершины до всех остальных при помощи очереди с
    приоритетами через использование кучи.

    Args:
    graph (dict): Граф, представленный в виде словаря смежности.
    start: Начальная вершина, с которой начинается поиск.

    Returns:
    dict: Словарь минимальных расстояний
    """
    # Создание словаря для хранения кратчайших расстояний от start до
    # каждой вершины
    distances = {i: float("inf") for i in graph}
    # Создаем кучу ("очередь" с приоритетами), в формате расстояние,
    # вершина
    heap = [(0, start)]
    # Установка расстояния до начальной вершины равным 0
    distances[start] = 0
    while heap:
        # Извлекаем расстояние и узел из начала кучи.
        distance, vertex = heapq.heappop(heap)
        # Перебираем всех соседей текущего узла.
        for neighbour in graph[vertex]:
            # Находим новое расстояние до текущего соседа
            new_distance = distance + graph[vertex][neighbour]
            # Если вновь найденное расстояние до соседа оказывается
            # меньше текущего расстояния, то
            if new_distance < distances[neighbour]:
                # Обновляем расстояние до соседа
                distances[neighbour] = new_distance
                # И добавляем соседа с обновленным расстоянием в кучу,
                # чтобы искать дальше уже его соседей.
                # Важный момент, что здесь засчет использования кучи
                # мы всегда держим вершину с минимальным расстоянием
                # наверху, что позволяет быстрее извлекать минимум.
                heapq.heappush(heap, (new_distance, neighbour))
    return distances


def choose_region_capitals(graph, starts):
    """
    Находит ближайший главный город для каждого города в графе.

    Алгоритм проходит по всем городам и для каждого из них определяет
    ближайший главный город, используя алгоритм Дейкстры для расчета
    кратчайших путей от каждого главного города до всех остальных.

    Args:
    graph (dict): Граф, представленный в виде словаря смежности, где
        ключи - вершины графа, а значения - словари соседних вершин с
        весами рёбер.
    starts (list): Список начальных вершин (главных городов округов).

    Returns:
    dict: Словарь, где ключи - вершины (города) графа, а значения -
        ближайшие главные города. Если город недостижим из любого из
        главных городов, его значение будет -1.
    """
    # Словарь для хранения ближайшего главного города каждого города
    capitals = {}
    # Перебираем все города в графе
    for city in graph:
        # Инициализируем переменную для хранения ближайшего главного
        # города
        closest_capital = None
        # Инициализируем расстояние до ближайшего главного города как
        # бесконечность
        closest_distance = float('inf')
        # Перебираем все главные города
        for start in starts:
            # Вычисляем кратчайшие пути от главного города до
            # всех остальных
            distances = dijkstra(graph, start)
            # Если найден более короткий путь до города
            if distances[city] < closest_distance:
                # Обновляем расстояние до ближайшего главного города
                closest_distance = distances[city]
                # Обновляем ближайший главный город
                closest_capital = start
        # Присваиваем городу его ближайший главный город (если так
        # и не обновили расстояние, т.е. осталось равно бесконечности,
        # значит город недостижим - устанавливаем -1.)
        capitals[city] = closest_capital if closest_distance != float('inf') else -1
    # Возвращаем словарь с ближайшими главными городами для каждого
    # города
    return capitals


def main():
    # graph, starts = create_adj_list()
    # print(graph)
    # print(starts)
    # Case 1
    graph = {
        '0': {'1': 34.0},
        '1': {'0': 34.0, '2': 7.0},
        '2': {'1': 7.0, '3': 85.0},
        '3': {'2': 85.0}
    }
    starts = ['0', '1']
    # # Case 2
    # graph = {
    #     '2': {'1': 24.0, '4': 1.0},
    #     '1': {'2': 24.0, '0': 78.0, '5': 51.0},
    #     '4': {'2': 1.0},
    #     '0': {'1': 78.0, '3': 19.0},
    #     '5': {'1': 51.0},
    #     '3': {'0': 19.0}
    # }
    # starts = ['0', '1']

    print(choose_region_capitals(graph, starts))


if __name__ == "__main__":
    main()
