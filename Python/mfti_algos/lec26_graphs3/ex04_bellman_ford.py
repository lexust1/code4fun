# Упражнение №4
# Решите задачу из упражнения №2, используя алгоритм Форда-Беллмана.
# Гарантируется, что циклов отрицательного веса в графе нет.
# Алгоритм Форда-Беллмана - это алгоритм поиска кратчайших путей в
# взвешенном графе, который способен работать с рёбрами отрицательного
# веса и обнаруживать циклы отрицательного веса.

# Ключевые положения:
# - Работает в графах с рёбрами отрицательного веса, что невозможно
#   для многих других алгоритмов, например, Дейкстры.
# - Способен обнаруживать циклы отрицательного веса в графе.
# - Подходит для использования в разреженных и плотных графах.

# Плюсы:
# + Универсальность: подходит для графов с рёбрами как положительного,
#   так и отрицательного веса.
# + Простота реализации: алгоритм легко кодируется и понимается.

# Минусы:
# - Высокая асимптотическая сложность: O(VE), где V - количество вершин,
#   E - количество рёбер. Это делает его менее эффективным на больших
#   графах по сравнению с другими алгоритмами, такими как Дейкстра
# - Может быть замедлен из-за наличия большого числа итераций для
# каждого ребра, особенно в плотных графах.

# Асимптотика: O(VE)
# Эта сложность обусловлена необходимостью прохода по всем рёбрам графа
# до V-1 раз для гарантии нахождения кратчайшего пути в худшем случае.
def create_edge_list():
    """
    Запрашивает у пользователя ввод данных графа и создаёт на его
    основе список рёбер и множество вершин.

    Функция запрашивает у пользователя количество вершин и рёбер, а
    затем каждое ребро в формате:
    начальная вершина, конечная вершина, вес ребра. На основе введённых
    данных формируется список рёбер и множество всех вершин графа.

    Returns:
    edges (list of tuples): Список кортежей, где каждый кортеж
        представляет ребро графа в формате (начальная вершина, конечная
        вершина, вес ребра).
    vertices (set): Множество всех уникальных вершин графа, полученных
        из списка рёбер.
    n (int): Количество вершин в графе, указанное пользователем.
    """
    # Вводим количество вершин (n) и рёбер (m)
    n, m = [int(x) for x in input().split()]
    # Инициализируем граф (через хранение листа ребер)
    edges = []
    # Инициализируем множество вершин, чтобы позднее создать словарь
    # для расстояний
    vertices = set()
    # Добавляем рёбра с весом
    for _ in range(m):
        v1, v2, weight = input().split()
        weight = float(weight)
        # Добавляем ребро в граф
        edges.append((v1, v2, weight))
        # Добавляем вершины
        vertices.add(v1)
        vertices.add(v2)
    return edges, vertices, n


def bellman_ford(edges, vertices, n, start):
    """
    Выполняет алгоритм Форда-Беллмана для нахождения кратчайших путей
    от стартовой вершины до всех других вершин в графе.

    Args:
    edges (list of tuples): Список кортежей, представляющих рёбра графа.
        Каждый кортеж имеет формат (u, v, weight), где u - начальная
        вершина ребра, v - конечная вершина, weight - вес ребра.
    vertices (set): Множество всех вершин графа.
    n (int): Количество вершин в графе.
    start (str): Идентификатор стартовой вершины, от которой будут
        вычисляться кратчайшие пути.

    Returns:
    dict: Словарь с кратчайшими расстояниями от стартовой вершины до
        каждой вершины графа. Ключи словаря - идентификаторы вершин,
        значения - расстояния. Возвращает None, если в графе обнаружен
        цикл отрицательного веса.
    """
    # Инициализация словаря расстояний, где ключ - вершина, значение -
    # расстояние от стартовой вершины.
    # Изначально для всех вершин, кроме стартовой, расстояние
    # устанавливается как бесконечность (float('inf')),
    # что символизирует, что расстояние до них пока неизвестно.
    distances = {vertex: float('inf') for vertex in vertices}
    # Устанавливаем расстояние от стартовой вершины до самой себя
    # равным 0, так как расстояние от вершины до неё же нулевое.
    distances[start] = 0
    # Основной цикл алгоритма выполняется (n - 1) раз, где n -
    # количество вершин в графе.
    # Это количество итераций гарантирует, что будут найдены кратчайшие
    # пути даже в самом длинном возможном пути
    # в графе без циклов (который может затрагивать все вершины).
    for _ in range(n - 1):
        # Проходим по всем рёбрам графа.
        for u, v, weight in edges:
            # Если текущее расстояние до начальной вершины ребра не
            # бесконечность (то есть уже было обновлено) и сумма
            # расстояния до начальной вершины ребра и веса ребра меньше
            # текущего расстояния до конечной вершины, то обновляем
            # расстояние до конечной вершины.
            if distances[u] != float('inf') and distances[u] + weight < distances[v]:
                distances[v] = distances[u] + weight
    # После выполнения основного цикла алгоритма, проводим проверку на
    # наличие циклов отрицательного веса.
    # Для этого ещё раз проходим по всем рёбрам.
    for u, v, weight in edges:
        # Если после всех итераций основного цикла можно уменьшить
        # расстояние до какой-либо вершины, это означает наличие цикла
        # отрицательного веса.
        # Такой цикл позволяет "бесконечно" уменьшать расстояние,
        # прибавляя к пути цикл и делая путь "короче".
        if distances[u] != float('inf') and distances[u] + weight < distances[v]:
            print("Граф содержит циклы отрицательного веса")
            # Возвращаем None, чтобы сигнализировать об ошибке в графе.
            return None
    # Если циклов отрицательного веса не обнаружено, возвращаем
    # расчитанные расстояния до всех вершин.
    return distances


def main():
    # graph = create_edge_list()
    # print(graph)
    edges, vertices, n = (
        [
            ('A', 'B', 2.0),
            ('B', 'C', 1.0),
            ('B', 'D', 5.0),
            ('C', 'D', 3.0),
            ('C', 'G', 1.0),
            ('G', 'F', 1.0),
            ('F', 'C', 2.0),
            ('D', 'F', 4.0),
            ('D', 'E', 6.0),
            ('E', 'F', 7.0),
            ('E', 'I', 2.0),
            ('F', 'H', 3.0),
            ('I', 'H', 12.0),
            ('A', 'H', 15.0),
            ('J', 'K', 2.0)
        ],
        {'E', 'I', 'D', 'G', 'F', 'C', 'J', 'K', 'A', 'B', 'H'},
        11
    )
    distances = bellman_ford(edges, vertices, n, "A")
    print(distances)


if __name__ == "__main__":
    main()
