# Упражнение №3
# Теперь решите задачу из упражнения №2, реализовав алгоритм Дейкстры
# за O((N+M) log N).
import heapq


def create_adj_list():
    """
    Создает представление графа в виде списка смежности.

    Returns:
    graph: dict, представление графа в виде списка смежности
    """
    # Вводим количество вершин (n) и рёбер (m)
    n, m = [int(x) for x in input().split()]
    # Инициализируем граф
    graph = {}
    # Добавляем рёбра с весом
    for _ in range(m):
        v1, v2, weight = input().split()
        weight = float(weight)
        # Добавляем ребро в граф
        add_edge(graph, v1, v2, weight)
    return graph


def add_edge(graph, v1, v2, weight):
    """
    Добавляет ребро между двумя вершинами с заданным весом в граф.

    Args:
    graph (dict): Граф, в который будет добавлено ребро.
    v1: Первая вершина ребра.
    v2: Вторая вершина ребра.
    weight: Вес ребра.
    """
    if v1 not in graph:
        # Если вершина v1 отсутствует в графе, добавить её с словарём,
        # содержащим v2 как ключ и вес как значение
        graph[v1] = {v2: weight}
        if v2 not in graph:
            graph[v2] = {}
    else:
        # Если вершина v1 присутствует в графе, обновить словарь,
        # добавив v2 как ключ и вес как значение
        graph[v1][v2] = weight


def dijkstra_heap(graph, start):
    """
    Реализация алгоритма Дейкстры для нахождения кратчайших путей от
    начальной вершины до всех остальных при помощи очереди с
    приоритетами через использование кучи.

    Args:
    graph (dict): Граф, представленный в виде словаря смежности.
    start: Начальная вершина, с которой начинается поиск.

    Returns:
    dict: Словарь предшественников, который позволяет восстановить
    кратчайший путь от начальной вершины до всех остальных.
    """
    # Создание словаря для хранения кратчайших расстояний от start до
    # каждой вершины
    distances = {i: float("inf") for i in graph}
    # Создаем кучу ("очередь" с приоритетами), в формате расстояние,
    # вершина
    heap = [(0, start)]
    # Установка расстояния до начальной вершины равным 0
    distances[start] = 0
    while heap:
        # Извлекаем расстояние и узел из начала кучи.
        distance, vertex = heapq.heappop(heap)
        # Перебираем всех соседей текущего узла.
        for neighbour in graph[vertex]:
            # Находим новое расстояние до текущего соседа
            new_distance = distance + graph[vertex][neighbour]
            # Если вновь найденное расстояние до соседа оказывается
            # меньше текущего расстояния, то
            if new_distance < distances[neighbour]:
                # Обновляем расстояние до соседа
                distances[neighbour] = new_distance
                # И добавляем соседа с обновленным расстоянием в кучу,
                # чтобы искать дальше уже его соседей.
                # Важный момент, что здесь засчет использования кучи
                # мы всегда держим вершину с минимальным расстоянием
                # наверху, что позволяет быстрее извлекать минимум.
                heapq.heappush(heap, (new_distance, neighbour))
    return distances


def main():
    # graph = create_adj_list()
    # print(graph)
    graph = {
        'A': {'B': 2.0, 'H': 15.0},
        'B': {'C': 1.0, 'D': 5.0},
        'C': {'D': 3.0, 'G': 1.0},
        'D': {'F': 4.0, 'E': 6.0},
        'G': {'F': 1.0},
        'F': {'C': 2.0, 'H': 3.0},
        'E': {'F': 7.0, 'I': 2.0},
        'I': {'H': 12.0},
        'H': {},
        'J': {'K': 2.0},
        'K': {}
    }
    distances = dijkstra_heap(graph, "A")
    print(distances)


if __name__ == "__main__":
    main()
