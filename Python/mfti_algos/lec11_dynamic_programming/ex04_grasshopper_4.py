# Восстановление наиболее выгодной траектории
# Итак, мы нашли список С, где будет записана минимальная стоимость
# маршрута для всех точек от 1 до n.
#
# Но помимо нахождения наименьшей стоимости маршрута, разумеется,
# хотелось бы найти и сам маршрут минимальной стоимости. Такая задача
# называется задачей «восстановления ответа».
#
# Для восстановления ответа будем для каждой точки запоминать номер
# точки prev[i], из которой кузнечик попал в точку i, если он будет
# передвигаться по пути минимальной стоимости. То есть prev[i] — это
# точка, предшествующая точке с номером i на пути минимальной стоимости
# (также говорят, что Prev — это массив предшественников).
# Как определить prev[i]? Если C[i-1] < C[i-2], то кузнечик попал в
# точку i из точки (i-1), поэтому prev[i] = i - 1,
# иначе prev[i] = i - 2.
#
# Для восстановления пути необходимо начать с точки n и переходить от
# каждой точки к ее предшественнику, пока путь не дойдет до начальной
# точки с номером 0. Номера всех вершин будем добавлять в список path.
# В конце в список path добавляется начальная вершина номер 1, которая
# не была обработана в основном цикле, а затем весь список path
# разворачивается в обратном порядке (т. к. вершины добавляются в
# обратном порядке, от конечной к начальной).
#
# Упражнение №4
# Модифицируйте алгоритм вычисления значений целевой функции так,
# чтобы вычислить значения prev[i], и восстановите траекторию
# наименьшей стоимости из точки 1 в точку n.
def count_min_cost_with_path(N, price):
    """
    Вычисляет минимальную стоимость достижения клетки N из клетки 1,
    при условии, что кузнечик может прыгать только на +1 и +2 клетки.
    """
    # Инициализация массива стоимостей C:
    #   C[1] - стоимость нахождения в первой клетке (price[1]),
    #   C[2] - стоимость перехода из клетки 1 в клетку 2.
    # Используется 'float("-inf")' для обозначения недостижимых клеток.
    C = [float("-inf"), price[1], price[1] + price[2]] + [0] * (N - 2)
    # Инициализация массива prev для хранения предыдущей клетки,
    # ведущей к минимальной стоимости в каждой клетке.
    prev = [0] * (N + 1)
    # Перебор каждой клетки от 3 до N.
    for i in range(3, N + 1):
        # Определение минимальной стоимости достижения клетки i.
        # Если стоимость достижения i-1 плюс цена прыжка в i меньше, чем
        # стоимость достижения i-2 плюс цена прыжка в i, то
        # используется i-1.
        if C[i - 1] < C[i - 2]:
            C[i] = C[i - 1] + price[i]
            prev[i] = i - 1
        else:
            # В противном случае используется i-2.
            C[i] = C[i - 2] + price[i]
            prev[i] = i - 2
    # Возвращение минимальной стоимости достижения клетки N и массива
    # prev для восстановления пути.
    return C[-1], prev


def reconstruct_path(prev, N):
    """
    Восстанавливает путь минимальной стоимости из клетки 1 в клетку N.
    """
    # Инициализация пустого списка для пути.
    path = []
    # Возвращение от клетки N к начальной клетке.
    while N > 0:
        # Добавление текущей клетки в путь.
        path.append(N)
        # Переход к предыдущей клетке на пути минимальной стоимости.
        N = prev[N]
    # Добавление начальной клетки в путь.
    path.append(1)
    # Переворачивание пути, чтобы он начинался с клетки 1 и
    # заканчивался в клетке N.
    return path[::-1]


def main():
    min_cost, prev = count_min_cost_with_path(4, [0, 2, 3, 5, 1])
    min_cost_path = reconstruct_path(prev, 4)
    print(min_cost, min_cost_path)


if __name__ == "__main__":
    main()
