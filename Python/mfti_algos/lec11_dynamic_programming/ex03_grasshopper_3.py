# Задача о кузнечике со стоимостями посещения точек
# Пусть кузнечик прыгает на одну или две точки вперед, а за прыжок в
# каждую точку необходимо заплатить определенную стоимость, различную
# для различных точек.
# Стоимость прыжка в точку i задается значением price[i] списка price.
# Необходимо найти минимальную стоимость маршрута кузнечика из точки 0
# в точку n.
#
# На этот раз нам необходимо модифицировать определение целевой функции.
# Пусть C[n] — минимальная стоимость пути из 1 в n.
#
# Выведем рекуррентное соотношение для этой функции.Чтобы попасть в
# точку n мы должны попасть в неё последним прыжком из (n-1) или (n-2).
# Минимальные стоимости этих маршрутов будут равны С[n-1] и С[n-2]
# соответственно, к ним придется добавить значение price[n] за прыжок
# в клетку n. Но из двух клеток мы можем выбрать любую.
#
# Нужно выбрать тот маршрут, который имеет наименьшую стоимость: \
#     C[n] = min(C[n-1], C[n-2]) + price[n]
#
# Вычислить значение целевой функции также лучше при помощи
# динамического программирования, а не рекурсии.
#
# Упражнение №3
# Напишите функцию calculate_min_cost(n, price) вычисления наименьшей
# стоимость достижения клетки n из клетки 1
def count_min_cost(N, price):
    """Минимальная стоимость достижения клетки, при этом допустимы
    прыжки только +1 и +2."""
    C = [float("-inf"), price[1], price[1] + price[2]] + [0] * (N - 2)
    for i in range(3, N + 1):
        C[i] = min(C[i - 1], C[i - 2]) + price[i]
    return C[N]


def main():
    print(count_min_cost(4, [0, 2, 3, 5, 1]))


if __name__ == "__main__":
    main()
