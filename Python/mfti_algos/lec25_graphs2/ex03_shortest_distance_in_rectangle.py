# Сдать решение задачи C-Поиск расстояния на прямоугольном поле
#
# Дано прямоугольное поле размера n строк на m столбцов. Некоторые
# ячейки поля непроходимы. Требуется найти расстояние между двумя
# заданными ячейками.
#
# Формат входных данных
# В первой строке два числа — n и m (1 <= n,m <= 500) . Во второй —
# номер строки и столбца начальной ячейки, в третьей — номер строки и
# столбца конечной ячейки. В остальных n строках задано поле. Каждая
# строка поля содержит m символов, X задает непроходимую ячейку,
# «пробел» — проходимую.
#
# Формат выходных данных
# Вывести одно число — расстояние между указанными ячейками (ходить
# можно только по горизонтали или вертикали). Если пути между этими
# ячейками нет, выведите "INF" без кавычек.
#
# Примеры
# Ввод	        Вывод
# 5 7             10
# 3 5
# 1 1
# XXXXXXX
# X X   X
# X X X X
# X   X X
# XXXXXXX
#
#
# Ввод	        Вывод
# 5 7             INF
# 3 5
# 1 1
# XXXXXXX
# X X   X
# X XXX X
# X   X X
# XXXXXXX
# ОЧЕНЬ СТРАННО ВЫГЛЯДЯТ ПРИМЕРЫ. НАПРИМЕР, ЯЧЕЙКА НА 11 С КРЕСТОМ,
# ОТТУДА НЕЛЬЗЯ ХОДИТЬ. ТАКЖЕ ЯЧЕЙКА 35 С КРЕСТОМ. КАК ПРИ ЭТОМ
# РАССТОЯНИЕ 10 - БОЛЬШОЙ ВОПРОС. ВЕРОЯТНО, ОПЕЧАТКА, ЛИБО ИСПОЛЬЗУЮТ
# НУМЕРАЦИЮ PYTHON. НО ПОСЛЕДНЕЕ ВЫГЛЯДИТ СТРАННО, Т.К. САМИ ГОВОРЯТ ЧТО
# НУМЕРАЦИЯ НАЧИНАЕТСЯ С ЕДИНИЦЫ. ЛИБО СЧИТАЮТ ГРАНИЦЫ, ВКЛЮЧЕННЫМИ
# В СОСТАВ. ПОЭТОМУ ЗАПРОС ДЕЛАЛ ДЛЯ 22 И 46, ЧТО И ХОТЕЛИ, ПО ФАКТУ,
# ПРОВЕРИТЬ.
# Ввод	        Вывод
# 5 7             10
# 4 6
# 2 2
# XXXXXXX
# X X   X
# X X X X
# X   X X
# XXXXXXX

# Ввод	        Вывод
# 5 7             10
# 4 6
# 2 2
# XXXXXXX
# X X   X
# X XXX X
# X   X X
# XXXXXXX
# O(V+E)
from collections import deque


def create_adj_list():
    """
    Функция для создания списка смежности графа из прямоугольника.

    Аргументы (вводятся пользователем):
        - Первая строка: два числа n и m, разделенные пробелом,
            где n - количество строк, а m - количество столбцов в
            прямоугольнике.
        - Вторая строка: начальная вершина в формате "17", где первая
            цифра - номер строки (счет с 1), вторая - номер столбца.
        - Третья строка: конечная вершина в таком же формате, как
            начальная.
        - Следующие n строк: описание прямоугольника, где " " (пробел)
            означает свободную ячейку, а "X" - непроходимую.

        Returns:
        - n, m (int): количество строк и столбцов в прямоугольнике.
        - start, end (str): начальная и конечная вершины.
        - graph (dict): представление графа в виде списка смежности,
            где ключи - это вершины, а значения - множества соседних
            вершин.
    """
    # Задаем число строк (n) и столбцов (m) в прямоугольнике
    n, m = [int(x) for x in input().split()]
    # Задаем начальную и конечную вершины в формате "17", где первое
    # число - это номер строки (счет с 1), второе - это номер столбца.
    start = input().replace(" ", "")
    end = input().replace(" ", "")
    # Возможные "ходы"
    # moves = [
    #     (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1)
    # ]
    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    # Создаем лист стрингов
    rectangle = []
    for _ in range(n):
        rectangle.append(input())
    # Инициализируем граф
    graph = {}
    # Проходимся через каждую ячейку заданного графа.
    for i in range(n):
        for j in range(m):
            # Если ячейка проходима
            if rectangle[i][j] == " ":
                # Создаем вершину в графе с пустым множеством
                vertex = f"{i + 1}{j + 1}"
                graph[vertex] = set()
                # Из каждой ячейки рассматриваем допустимы ходы к
                # соседям
                for dx, dy in moves:
                    new_i, new_j = i + dx, j + dy
                    # Если не выходим за границы прямоугольника и сосед
                    # не является непроходимой ячейкой, заносим соседа
                    # во множество текущей ячейки.
                    if (0 <= new_i < n and
                            0 <= new_j < m and
                            rectangle[new_i][new_j] != "X"):
                        neighbour = f"{new_i + 1}{new_j + 1}"
                        graph[vertex].add(neighbour)
    return n, m, start, end, graph


def bfs(graph, start, end):
    """
    Выполняет обход графа в ширину (Breadth-First Search, BFS) и
    вычисляет расстояние от начальной вершины до конечной.

    Функция использует очередь для обработки узлов графа. Каждый узел
    сначала проверяется на наличие в множестве посещенных узлов. Если
    узел не посещен, он добавляется в множество посещенных и в очередь.
    При этом обновляется расстояние от начального узла до текущего.
    Обход прекращается, как только найдена конечная вершина, и
    возвращается расстояние до неё.
    Если конечная вершина недостижима, возвращает float('inf').

    Args:
    graph (dict): Граф, представленный в виде словаря, где ключи -
        это узлы, а значения - множества соседних узлов.
    start (str): Начальный узел, с которого начинается обход.
    end (str): Конечный узел, до которого нужно вычислить расстояние.

    Returns:
    int: Расстояние от начальной до конечной вершины, если оно существует,
         иначе float('inf').
    """
    # Инициализируем множество для отслеживания посещенных узлов
    visited = set()
    # Создаем двустороннюю очередь (deque) и помещаем в нее начальный
    # узел.
    queue = deque([start])
    # Добавляем начальный узел в множество посещенных.
    visited.add(start)
    # Создаем словарь расстояний с бесконечностями
    distances = {i: float('inf') for i in graph}
    # Расстояние до стартовой вершины
    distances[start] = 0
    # Продолжаем выполнять цикл, пока очередь не пуста
    while queue:
        # Извлекаем узел из начала очереди.
        vertex = queue.popleft()
        # Проверяем, достигли ли искомой вершины, чтобы не ходить через
        # оставшийся граф. Своеобразная оптимизация.
        if vertex == end:
            return distances[end]
        # # Выводим узел, на каждом шаге. Но оформляем все в одну строку.
        # print(str(vertex), end=" ")
        # Перебираем всех соседей текущего узла.
        for neighbour in graph[vertex]:
            # Если сосед еще не был посещен, добавляем его в множество
            # посещенных и в очередь.
            if neighbour not in visited:
                # Помечаем соседа как посещенный.
                visited.add(neighbour)
                # Добавляем соседа в очередь для дальнейшего обхода.
                queue.append(neighbour)
                # Обновляем расстояние до соседа
                distances[neighbour] = distances[vertex] + 1
    return distances[end]


def main():
    # n, m, start, end, graph = create_adj_list()
    n, m, start, end, graph = (
        5,
        7,
        '22',
        '46',
        {
            '22': {'32'},
            '24': {'25', '34'},
            '25': {'26', '24'},
            '26': {'36', '25'},
            '32': {'42', '22'},
            '34': {'44', '24'},
            '36': {'26', '46'},
            '42': {'43', '32'},
            '43': {'42', '44'},
            '44': {'43', '34'},
            '46': {'36'}
        }
    )
    print(bfs(graph, start, end))


if __name__ == "__main__":
    main()
