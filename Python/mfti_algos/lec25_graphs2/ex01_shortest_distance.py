# Сдать решение задачи A-Поиск кратчайшего пути между двумя узлами
# невзвешенного графа
#
# Дан невзвешенный связный граф. Вершины пронумерованы от 0. Трeбуется
# с помощью обхода в ширину найти расстояние от одной указанной вершины
# до другой.
#
# Формат входных данных
# На вход программе в первой строке подаются через пробел четыре числа:
# n, m, x, y.
# Число n (2 <= n <= 1000) - количество вершин в графе,
# m (1 <= m <= 20000) - количество ребер. x и y - начальная и конечная
# вершины соответственно (0 <= x,y < n). В следующих m строках задаются
# ребра, по два числа в каждой строке - номера соединенных вершин.
#
# Формат выходных данных
# Требутеся распечатать одно число - расстояние от вершины x до
# вершины y .
#
# Примеры
# Ввод	    Вывод
# 2 1 0 1     1
# 0 1
#
#
# Ввод	    Вывод
# 8 10 5 2    3
# 4 7
# 5 1
# 0 1
# 3 1
# 0 2
# 3 5
# 3 4
# 0 4
# 4 6
# 5 4
#
# O(V+E)
from collections import deque


def create_adj_list():
    # Задаем число вершин (n), ребер (m), начальную и конечные вершины.
    n, m, start, end = [x for x in input().split()]
    n, m = int(n), int(m)
    graph = {str(i): set() for i in range(n)}
    # Проходим по всем ребрам графа
    for _ in range(m):
        # Считываем вершины, соединенные ребром
        v1, v2 = input().split()
        # Т.к. граф не направленный, смотри в обоих направлениях
        for v, u in (v1, v2), (v2, v1):
            graph[v].add(u)
    return graph, start, end


def bfs(graph, start, end):
    """
    Выполняет обход графа в ширину (Breadth-First Search, BFS) и
    вычисляет расстояние от начальной вершины до конечной.

    Функция использует очередь для обработки узлов графа. Каждый узел
    сначала проверяется на наличие в множестве посещенных узлов. Если
    узел не посещен, он добавляется в множество посещенных и в очередь.
    При этом обновляется расстояние от начального узла до текущего.
    Обход прекращается, как только найдена конечная вершина, и
    возвращается расстояние до неё.
    Если конечная вершина недостижима, возвращает float('inf').

    Args:
    graph (dict): Граф, представленный в виде словаря, где ключи -
        это узлы, а значения - множества соседних узлов.
    start (str): Начальный узел, с которого начинается обход.
    end (str): Конечный узел, до которого нужно вычислить расстояние.

    Returns:
    int: Расстояние от начальной до конечной вершины, если оно существует,
         иначе float('inf').
    """
    # Инициализируем множество для отслеживания посещенных узлов
    visited = set()
    # Создаем двустороннюю очередь (deque) и помещаем в нее начальный
    # узел.
    queue = deque([start])
    # Добавляем начальный узел в множество посещенных.
    visited.add(start)
    # Создаем словарь расстояний с бесконечностями
    distances = {i: float('inf') for i in graph}
    # Расстояние до стартовой вершины
    distances[start] = 0
    # Продолжаем выполнять цикл, пока очередь не пуста
    while queue:
        # Извлекаем узел из начала очереди.
        vertex = queue.popleft()
        # Проверяем, достигли ли искомой вершины, чтобы не ходить через
        # оставшийся граф. Своеобразная оптимизация.
        if vertex == end:
            return distances[end]
        # # Выводим узел, на каждом шаге. Но оформляем все в одну строку.
        # print(str(vertex), end=" ")
        # Перебираем всех соседей текущего узла.
        for neighbour in graph[vertex]:
            # Если сосед еще не был посещен, добавляем его в множество
            # посещенных и в очередь.
            if neighbour not in visited:
                # Помечаем соседа как посещенный.
                visited.add(neighbour)
                # Добавляем соседа в очередь для дальнейшего обхода.
                queue.append(neighbour)
                # Обновляем расстояние до соседа
                distances[neighbour] = distances[vertex] + 1
    return distances[end]


def main():
    graph, start, end = create_adj_list()
    # graph, start, end = {'0': {'1'}, '1': {'0'}}, "0", "1"

    print(graph, start, end)
    print(bfs(graph, start, end))


if __name__ == "__main__":
    main()
