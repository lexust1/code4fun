# Сдать решение задачи F-Таблица
#
# Дана таблица, состоящая из N строк и M столбцов. В каждой клетке
# таблицы записано одно из чисел: 0 или 1. Расстоянием между клетками
# (x1, y1) и (x2, y2) назовем сумму |x1-x2|+|y1-y2|. Вам необходимо
# построить таблицу, в клетке (i, j) которой будет записано минимальное
# расстояние между клеткой (i, j) начальной таблицы и клеткой, в
# которой записана 1. Гарантируется, что хотя бы одна 1 в таблице есть.
#
# Формат входных данных
# В первой строке вводятся два натуральных числа N и M, не
# превосходящих 500. Далее идут N строк по M чисел - элементы таблицы.
#
# Формат выходных данных
# Требуется вывести N строк по M чисел - элементы искомой таблицы.
#
# Примеры
# Ввод
# 2 3
# 0 0 1
# 1 0 0
# Вывод
# 1 1 0
# 0 1 1
from collections import deque


def create_input_data():
    """
    Считывает входные данные для задачи.

    Функция запрашивает сначала два числа N и M через стандартный ввод,
    которые представляют количество строк и столбцов в таблице
    соответственно.
    Затем считывает N строк, каждая из которых содержит M чисел
    (0 или 1), разделенных пробелами, представляющих собой элементы
    таблицы.

    Returns:
        tuple: Возвращает кортеж, состоящий из трех элементов:
            - n (int): количество строк в таблице,
            - m (int): количество столбцов в таблице,
            - arr (list of lists of int): двумерный список,
            представляющий таблицу.
    """
    # Считывание размеров таблицы. Ввод предполагается в формате "N M",
    # где N - количество строк, M - количество столбцов.
    n, m = [int(x) for x in input().split()]
    # Инициализация списка для хранения таблицы.
    arr = []
    # Считывание самой таблицы. Для каждой из N строк вводится M чисел,
    # каждое из которых может быть либо 0, либо 1.
    for _ in range(n):
        arr.append([int(el) for el in input().split()])
    # Возвращаем кортеж с размерами таблицы и самой таблицей.
    return n, m, arr


def bfs(n, m, arr):
    """
    Выполняет поиск в ширину (BFS), чтобы найти минимальное расстояние
    от каждой клетки до ближайшей клетки с 1.

    Args:
        n (int): Количество строк в таблице.
        m (int): Количество столбцов в таблице.
        arr (list of lists of int): Двумерный список, представляющий
        таблицу, где каждый элемент - это 0 или 1.

    Returns:
        list of lists of int: Двумерный список, где для каждой клетки
        указано минимальное расстояние до ближайшей клетки с 1.
    """
    # Инициализация множества посещенных клеток
    visited = set()
    # Инициализация таблицы расстояний бесконечностями
    distances = [[float("inf")] * m for _ in range(n)]
    # Инициализация очереди для BFS
    queue = deque()
    # Заполнение начальных условий для клеток с 1 и их добавление в
    # очередь
    for i in range(n):
        for j in range(m):
            if arr[i][j] == 1:
                # Расстояние до самой себя равно 0
                distances[i][j] = 0
                # Добавление клетки в очередь
                queue.append((i, j))
                # Помечаем клетку как посещенную
                visited.add((i, j))
    # Определение возможных направлений движения: вверх, вправо, вниз,
    # влево
    moves = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    # Основной цикл BFS
    while queue:
        # Извлечение клетки из очереди
        x, y = queue.popleft()
        # Перебор всех возможных направлений движения (соседних клеток)
        for dx, dy in moves:
            # Новые координаты клетки после сдвига
            new_x, new_y = x + dx, y + dy
            # Проверяем что новые координаты (соседней ячейки) не
            # выходят за пределы таблицы и ранее ячейка не посещалась
            if (0 <= new_x < n and
                    0 <= new_y < m and
                    (new_x, new_y) not in visited):
                # Помечаем клетку как посещенную
                visited.add((new_x, new_y))
                # Добавление новой клетки в очередь для дальнейшего
                # рассмотрения
                queue.append((new_x, new_y))
                # Обновление расстояния
                distances[new_x][new_y] = distances[x][y] + 1
    # Возвращение таблицы с минимальными расстояниями
    return distances


def main():
    n, m, arr = create_input_data()
    print(arr)
    distances = bfs(n, m, arr)
    print(distances)


if __name__ == "__main__":
    main()
