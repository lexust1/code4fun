# Сдать решение задачи H-Нахождение кратчайшего цикла в ориентированном
# невзвешенном графе
#
# Дан ориентированный граф. Вершины пронумерованы от 0. Трeбуется с
# помощью обхода в ширину найти цикл минимальной длины.
#
# Формат входных данных
# На вход программе в первой строке подаются через пробел два числа:
# n (2 <= n <= 1000) - число вершин в графе и m (1 <= m <= 20000) -
# число ребер. В следующих m строках задаются ребра, по два числа в
# каждой строке - номера соединенных вершин (соответствующее ребро
# идет из первой вершины во вторую).
#
# Формат выходных данных
# Требуется распечатать номера вершин, задающих минимальный цикл
# в графе. Номера вершин нужно вывести в порядке следования по циклу.
# Если минимальных циклов несколько вывести любой. Если циклов нет
# вывести строку "NO CYCLES" без кавычек.
#
# Примеры
# Ввод	Вывод
# 4 1     NO CYCLES
# 3 1
#
#
# Ввод
# 8 8
# 7 3
# 3 1
# 5 2
# 6 4
# 6 7
# 4 7
# 1 6
# 1 2
# Вывод
# 1 6 7 3
# В этой версии реализовано:
# Также можно упростить, не восстанавливая цикл в каждом случае,
# а считая только расстояния цикла. И только после определения
# минимального расстояния, что говорит о кратчайшем цикле, провести
# востановление один раз.

# Есть еще вариант из каждой вершины запускать алгоритм Дейкстры, как
# читал в одном из мест.
from collections import deque


def create_adj_list():
    # Задаем число ребер (m) и вершин (n) графа
    n, m = [int(x) for x in input().split()]
    graph = {str(i): set() for i in range(n)}
    # Проходим по всем ребрам графа
    for _ in range(m):
        # Считываем вершины, соединенные ребром
        v1, v2 = input().split()
        graph[v1].add(v2)
    return graph


def bfs(graph, start):
    """
    Выполняет обход графа в ширину (Breadth-First Search, BFS) и
    обнаруживает циклы, исходящие из начальной вершины.

    Функция использует очередь для обработки узлов графа и множество для
    отслеживания посещенных узлов. При обнаружении соседней вершины,
    которая уже была посещена и не является непосредственным
    предшественником текущей вершины, фиксируется наличие цикла.
    Функция возвращает информацию о предшественниках в цикле, а также
    пару вершин, указывающих на наличие цикла.
    Если циклов, исходящих из начальной вершины, нет, возвращается
    False.

    Args:
    graph (dict): Граф, представленный в виде словаря, где ключи -
        это узлы, а значения - множества соседних узлов.
    start (str): Начальный узел, с которого начинается обход.

    Returns:
    tuple: (predecessors, end1, end2), где 'predecessors' - это словарь
        предшественников для каждой вершины, 'end1' и 'end2' -
        пара вершин, указывающая на наличие цикла.
        Если цикл не найден, возвращает False.
    """
    # Инициализируем множество для отслеживания посещенных узлов
    visited = set()
    # Создаем двустороннюю очередь (deque) и помещаем в нее начальный
    # узел.
    queue = deque([start])
    # Добавляем начальный узел в множество посещенных.
    visited.add(start)
    # Создаем словарь предшественников
    predecessors = {i: None for i in graph}
    # Создаем словарь расстояний с бесконечностями
    distances = {i: float('inf') for i in graph}
    # Расстояние до стартовой вершины
    distances[start] = 0
    # Продолжаем выполнять цикл, пока очередь не пуста
    while queue:
        # Извлекаем узел из начала очереди.
        vertex = queue.popleft()
        # Перебираем всех соседей текущего узла.
        for neighbour in graph[vertex]:
            # Если сосед еще не был посещен, добавляем его в множество
            # посещенных и в очередь.
            if neighbour not in visited:
                # Помечаем соседа как посещенный.
                visited.add(neighbour)
                # Добавляем соседа в очередь для дальнейшего обхода.
                queue.append(neighbour)
                # Сохраняем предшественника для соседа
                predecessors[neighbour] = vertex
                # Обновляем расстояние до соседа
                distances[neighbour] = distances[vertex] + 1
            # Если сосед не является предшественником текущей вершины,
            #  и сосед равен стартовой вершине это говорит о том, что
            # мы нашли цикл.
            elif neighbour != predecessors[vertex] and neighbour == start:
                # print(f"There is a cycle: {neighbour}, {predecessors[vertex]}")
                # возвращаем лист предшественников и соседа с текущей
                # вершиной, которые указали, где образуется цикл.
                return predecessors, neighbour, vertex, distances[vertex] + 1
    # Если нет циклов
    return False


def find_shortest_cycle(graph):
    """
    Находит кратчайший цикл в графе, если таковой существует.

    Функция перебирает все вершины графа, используя алгоритм BFS,
    начиная с каждой вершины, для поиска циклов. Для каждого найденного
    цикла вычисляется его длина, и выбирается самый короткий.

    Args:
    graph (dict): Граф, представленный в виде словаря списков смежности.

    Returns:
    list: Список вершин, составляющих кратчайший цикл, или строку
        "No cycles", если циклов в графе не найдено.
    """
    # Инициализация длины цикла бесконечностью с целью поиска
    # минимального графа
    cycle_length = float("inf")
    # Список для хранения вершин текущего кратчайшего цикла
    cycle = []
    # Перебор всех вершин графа
    for vertex in graph:
        # Поиск цикла с помощью BFS
        candidate = bfs(graph, vertex)
        # print(f"Candidate: {candidate}")
        # Если цикл не найден и это первая итерация
        if not candidate and cycle == []:
            cycle = "No cycles"
            # print(f"No cycle when we start from vertex {vertex}")
        # Если цикл не найден, пропускаем итерацию
        elif not candidate:
            continue
        # Если найден цикл
        else:
            # Обновляем кратчайший цикл, если найденный короче текущего
            if candidate[3] < cycle_length:
                cycle_length = candidate[3]
                cycle = candidate
    # Возвращаем цикл
    return cycle


def reconstruct_cycle(predecessors, end1, end2):
    """
    Реконструирует цикл в направленном графе, используя предшественников.

    Args:
    predecessors (dict): Словарь, где ключами являются вершины, а
        значениями - их предшественники.
    end1 (int): Начальная вершина цикла.
    end2 (int): Конечная вершина цикла, с которой начался поиск.

    Returns:
    list: Список вершин, составляющих цикл, если таковой существует.
    False: Если цикл не может быть реконструирован.
    """
    # Начинаем с конечной вершины end2
    cycle = []
    vertex = end2
    # Перемещаемся по предшетсвенникам от конечной вершины пока не
    # наталкнемся на начальную вершину
    while vertex != end1:
        # Получаем предсшественника текущей вершины
        vertex = predecessors[vertex]
        # Если предшественник есть, добавляем в цикл.
        cycle.append(vertex)
    # Добавляем конечную вершину для завершенности цикла
    cycle.append(end2)
    cycle = cycle[::-1]
    return cycle


def main():
    # print(create_adj_list())
    # graph = create_adj_list()
    # print(graph)
    graph = {
        '0': set(),
        '1': {'6', '2'},
        '2': set(),
        '3': {'1'},
        '4': {'7'},
        '5': {'2'},
        '6': {'4', '7'},
        '7': {'3'}
    }
    cycle = find_shortest_cycle(graph)
    print(cycle)
    path = reconstruct_cycle(*cycle[:-1])
    print(path)


if __name__ == "__main__":
    main()
