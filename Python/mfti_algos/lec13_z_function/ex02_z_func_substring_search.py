# Упражнение №2: Поиск подстроки
# Пусть даны две строки. Найти все вхождения второй строки в первую.

# Для нахождения всех вхождений одной строки в другую можно использовать
# алгоритм Z-функции. Этот метод особенно эффективен, когда необходимо
# найти все вхождения подстроки в строку. Вот как это можно сделать:
#
# Конкатенация строк: Сначала конкатенируем две строки, разделяя их
# специальным символом, который не встречается ни в одной из строк.
# Например, если у нас есть строки s1 и s2, мы создаем новую строку
# s = s2 + '#' + s1.
#
# Вычисление Z-функции: Затем вычисляем Z-функцию для полученной
# строки s.
#
# Поиск вхождений: Вхождение s2 в s1 обнаруживается каждый раз, когда
# значение Z-функции равно длине s2. Эти позиции указывают на начало
# каждого вхождения s2 в s1.
def z_func(s, n):
    """
    Вычисляет Z-функцию для строки.

    Args:
    s (str): Строка, для которой вычисляется Z-функция.

    Returns:
    list: Список, содержащий значения Z-функции для каждого индекса строки.
    """
    n = len(s)  # Определяем длину строки s
    z = [0] * n  # Создаем массив Z-функции длины n, инициализированный нулями
    l, r = 0, 0  # Устанавливаем начальные границы самого правого отрезка совпадения
    for i in range(1, n):  # Итерируемся по всем позициям строки, начиная со второй
        if i <= r:  # Проверяем, находится ли текущая позиция i в пределах отрезка [l; r]
            # Инициализируем z[i] меньшим из двух значений:
            # 1. r - i + 1: Максимальное количество символов, которое может совпадать с началом строки,
            #    начиная с позиции i, на основе уже известных данных.
            # 2. z[i - l]: Соответствующее значение Z-функции из предыдущего совпадения.
            # Это предотвращает необходимость в повторных сравнениях символов.
            z[i] = min(r - i + 1, z[i - l])
        # Продолжаем сравнивать символы после предполагаемого совпадения до тех пор,
        # пока они совпадают и пока не достигнут конца строки
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:  # Если новый отрезок совпадения выходит за границу r
            l, r = i, i + z[i] - 1  # Обновляем границы самого правого отрезка совпадения
    return z


def find_occurrences(s1, s2):
    """
    Находит все вхождения строки s2 в строке s1.

    Args:
    s1 (str): Строка, в которой ищутся вхождения.
    s2 (str): Подстрока, вхождения которой ищутся в s1.

    Returns:
    list: Список индексов, на которых начинаются вхождения s2 в s1.
    """
    concatenated = s2 + "#" + s1  # Объединяем строки с уникальным разделителем
    z = z_func(concatenated, len(concatenated))  # Вычисляем Z-функцию для объединенной строки
    len_s2 = len(s2)  # Длина искомой подстроки s2
    occurrences = []  # Список для хранения индексов вхождений

    # Проходим по Z-функции, начиная с индекса, следующего за s2 и разделителем
    for i in range(len_s2 + 1, len(concatenated)):
        # Проверяем, совпадает ли значение Z-функции с длиной s2
        # и соответствует ли найденная подстрока s2
        if z[i] == len_s2 and concatenated[i : i + z[i]] == s2:
            # Добавляем индекс начала вхождения в s1
            occurrences.append(i - (len_s2 + 1))
    return occurrences


def main():
    s1 = "abcdefabcabcdefabcdef"
    s2 = "abc"
    print(find_occurrences(s1, s2))


if __name__ == "__main__":
    main()
