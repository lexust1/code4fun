# Упражнение №1: Z
# -функция
# Напишите Z
# -функцию. Пусть заголовком ее будет def z_func(s, n):
#
# # O(m + n)
# Основная идея Z-алгоритма заключается в эффективном поиске всех вхождений
# подстроки в строку. Это достигается путем создания специального массива,
# называемого Z-массивом, который для каждой позиции в строке указывает на
# максимальную длину подстроки, начинающейся с этой позиции и совпадающей
# с началом всей строки. Проще говоря, Z-алгоритм помогает быстро определить,
# где и как часто повторяются части строки.
#
# Инициализация Z-массива: Сначала создается массив, где каждый элемент
# изначально равен нулю. Этот массив будет заполнен значениями в процессе
# работы алгоритма.
#
# Поиск Совпадений: Алгоритм проходит по строке и для каждой позиции пытается
# найти максимально длинную подстроку, которая совпадает с началом строки.
# Например, если строка начинается с "абра", алгоритм проверит, начинается ли
# подстрока с позиции 2, 3, 4 и так далее, также с "абра".
#
# Заполнение Z-массива: Каждый раз, когда находится такое совпадение,
# длина этой подстроки записывается в Z-массив на соответствующей позиции.
# Так, если на позиции 5 начинается подстрока "абра", в пятом элементе
# массива будет записано число 4 (длина "абра").
#
# Оптимизация поиска: Алгоритм использует "окно" совпадения и ранее найденные
# значения для уменьшения количества необходимых сравнений. Если часть строки
# уже была проверена и она встречается снова внутри текущего "окна",
# алгоритм использует ранее вычисленные значения, вместо того чтобы снова
# сравнивать символы.
#
# Применение: Полученный Z-массив может быть использован для быстрого
# определения вхождений подстрок в строку, что полезно во многих задачах,
# связанных с обработкой текста.
#
# Начальное состояние:
#
# Строка: abcababc
# Префикс: a
# "Окно": Начальный символ 'a'
# l = 0, r = 0
#
# i = 1 ("b"):
# "Окно": b (сравниваем с 'a')
# l = 0, r = 0, s[r - l] == s[1 - 0] == s[1] == 'b'
# Совпадений нет, Z[1] = 0
#
# i = 2 ("c"):
# "Окно": c (сравниваем с 'a')
# l = 0, r = 0, s[r - l] == s[2 - 0] == s[2] == 'c'
# Совпадений нет, Z[2] = 0
#
# i = 3 ("a"):
# Начинаем с i = 3, соответствующего символу "a".
# l = 0 и r = 0. Здесь начинается новое "окно" сравнения.
# Сравнение:
# s[3] ("a") с s[0] ("a"). Совпадение, увеличиваем r на 1 (r = 4).
# s[4] ("b") с s[1] ("b"). Еще одно совпадение, r теперь 5.
# Z[3] устанавливается равным r - l = 5 - 3 = 2.
# Обновляем l = 3 и r = 5.
#
# i = 4 ("b"):
# "Окно": b (сравниваем с 'a')
# l = 3, r = 4, s[r - l] == s[4 - 3] == s[1] == 'b'
# Совпадений нет, Z[4] = 0
#
# i = 5 ("a"):
# Теперь i = 5, символ "a".
# Так как i = r, начинаем новый поиск с этой позиции.
# Сравнение:
# s[5] ("a") с s[0] ("a"). Совпадение, увеличиваем r (r = 6).
# s[6] ("b") с s[1] ("b"). Снова совпадение, r = 7.
# s[7] ("c") с s[2] ("c"). Третье совпадение, r = 8.
# Z[5] устанавливается равным r - l = 8 - 5 = 3.
# Обновляем l = 5 и r = 8.
#
# i = 6 ("b"):
# "Окно": b (сравниваем с 'a')
# l = 5, r = 7, s[r - l] == s[6 - 5] == s[1] == 'b'
# Совпадений нет, Z[6] = 0
#
# i = 7 ("c"):
# "Окно": c (сравниваем с 'a')
# l = 5, r = 7, s[r - l] == s[7 - 5] == s[2] == 'c'
# Совпадений нет, Z[7] = 0
# Результат: Z-массив [0, 0, 0, 2, 0, 3, 0, 0].


# Основная Идея:
#
# Изначально алгоритм сравнивает префикс строки с "окном", которое
# расширяется, пока продолжаются совпадения. После окончания совпадения
# возникает вопрос:
#
# "Нужно ли начинать сравнение заново для следующего символа, или можно
#  использовать информацию, полученную ранее?"
#
# Пример с "abcababc":
#
# Когда находится совпадение "abc" начиная с позиции 5, устанавливаются
# значения l = 5 и r = 8.
# Далее, при переходе к i = 6, мы находимся в пределах уже изученного
# "окна" (l ≤ i < r).
#
# Оптимизация:
#
# Вместо нового сравнения с начала строки, алгоритм обращается к уже
# вычисленным значениям Z-массива.
# Значение k = i - l соответствует позиции в начале строки, которая
# представляет аналогичную ситуацию внутри "окна".
# Если Z[k] меньше, чем размер оставшейся части "окна", мы можем быть
# уверены, что для i количество совпадений будет таким же, и д
# ополнительные сравнения не требуются.
#
# Пример Оптимизации:
#
# Обратимся к i = 6 в строке "abcababc". Здесь k = 6 - 5 = 1,
# и Z[1] = 0.
# Это означает, что начиная с позиции i = 6 в "окне", нет совпадений
# длиной более 0. Таким образом, мы устанавливаем Z[6] = 0 без
# дополнительных сравнений.
#
# Ключевой момент оптимизации — использование ранее полученной
# информации для уменьшения количества сравнений, что особенно ценно
# в строках с повторяющимися участками.

def z_func(s, n):
    """
    Вычисляет Z-массив для данной строки.

    Args:
    s (str): Строка, для которой нужно вычислить Z-массив.
    n (int): Длина строки s.

    Returns:
    list: Z-массив, где Z[i] представляет максимальную длину подстроки,
          начинающейся с позиции i и совпадающей с префиксом строки s.
    """
    # Инициализация Z-массива нулями.
    Z = [0] * n
    # Инициализация границ "окна" сравнения.
    l, r = 0, 0
    # Основной цикл для вычисления Z-значений.
    for i in range(1, n):
        if i > r:
            # Запуск нового "окна" сравнения, если текущая позиция
            # находится за пределами текущего "окна".
            l, r = i, i
            # Расширение "окна" сравнения до тех пор, пока символы совпадают
            # с началом строки или пока не достигнут конец строки.
            while r < n and s[r - l] == s[r]:
                r += 1
            # Запись длины найденного совпадения в Z-массив.
            Z[i] = r - l
            # Корректировка правой границы "окна" после нахождения совпадения.
            r -= 1
        else:
            # Использование ранее вычисленных Z-значений для оптимизации.
            k = i - l
            # Если найденное ранее Z-значение не выходит за пределы "окна",
            # используем его.
            if Z[k] < r - i + 1:
                Z[i] = Z[k]
            else:
                # Иначе запускаем новый поиск совпадений, начиная с i.
                l = i
                while r < n and s[r - l] == s[r]:
                    r += 1
                # Запись длины найденного совпадения в Z-массив.
                Z[i] = r - l
                # Корректировка правой границы "окна" после нахождения совпадения.
                r -= 1
    return Z


def main():
    # print(z_func("abababa", 7))
    print(z_func("abcababc", 8))
    print(z_func("abcabcabc", 9))


if __name__ == "__main__":
    main()
