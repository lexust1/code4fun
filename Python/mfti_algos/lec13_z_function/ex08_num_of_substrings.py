# Упражнение №8: Количество разных подстрок
# Найти число всех различных подстрок входящих в данную с помощью
# префикс-функции.
#
# Поиск показал, что задача весьма странная. Даже через использование
# z-функции она не выглядела оптимально. Через использование
# пи-функции, через КМП - это выгялядит еще более громоздко и
# сопоставимо с решением банального перебора все подстрок внутри строки.
# Возможно, даже комбинаторное решение с применением оптимизации может
# выглядеть не самым плохим вариантом.
# Интересные мысли приведены здесь:
# https://stackoverflow.com/a/41092002
# https://www.quora.com/How-do-I-count-the-number-of-distinct-substrings-in-a-given-string-by-the-use-of-the-KMP-prefix-function
#
# Но как я понимаю, оптимальный способ, это использовать суффиксные
# деревья. Вероятно, это будет рассмотрено позднее. Пока же используем
# пи-функции и некий перебор, что позволяет выйти на асимпотику O(n^2).
# Лучше, чем перебором, где O(n^3).
#
def compute_pi_function(string):
    """
    Вычисляет пи-функцию для заданной строки.
    Пи-функция указывает длину наибольшего совпадающего префикса,
    который также является суффиксом
    для подстроки, заканчивающейся на каждом символе.

    Args:
    string (str): Строка, для которой вычисляется пи-функция.

    Returns:
    list: Массив, представляющий пи-функцию строки.
    """
    length = len(string)
    pi = [0] * length  # Инициализация массива пи-функции нулями
    j = 0  # Индекс для отслеживания длины текущего префикса
    # Проходим по строке, начиная со второго символа
    for i in range(1, length):
        # Пока j > 0 и текущий символ не совпадает с символом в префиксе,
        # возвращаемся к предыдущему возможному префиксу
        while j > 0 and string[j] != string[i]:
            j = pi[j - 1]
        # Если символы совпадают, увеличиваем j и обновляем пи-функцию
        if string[j] == string[i]:
            j += 1
        pi[i] = j
    return pi


def count_distinct_substrings(s):
    """
    Подсчитывает количество уникальных подстрок в заданной строке.

    Args:
    s (str): Строка, для которой необходимо подсчитать уникальные подстроки.

    Returns:
    int: Количество уникальных подстрок в строке.

    Описание работы функции:
    1. Для каждого суффикса строки s вычисляется пи-функция для строки, составленной из этого суффикса,
       символа-разделителя '#' и исходной строки s.
    2. Для каждого суффикса определяется максимальная длина повторяющегося префикса.
    3. Вычитая эту длину из длины суффикса, получаем количество уникальных подстрок,
       которые встречаются впервые в данном суффиксе.
    4. Суммируя полученные значения для всех суффиксов, получаем общее количество уникальных подстрок в строке s.
    """
    n = len(s)  # Длина исходной строки
    total = 0    # Общее количество уникальных подстрок
    for j in range(n):
        t = s[j:]  # Текущий суффикс строки s
        augmented_string = t + '#' + s  # Расширенная строка, содержащая суффикс, символ '#' и исходную строку
        pi = compute_pi_function(augmented_string)  # Вычисление пи-функции для расширенной строки
        max_prefix = 0  # Максимальная длина повторяющегося префикса в суффиксе
        for i in range(len(t)):
            max_prefix = max(max_prefix, pi[i])  # Определение максимальной длины повторяющегося префикса
        total += len(t) - max_prefix  # Подсчет уникальных подстрок для данного суффикса
    return total  # Возвращение общего количества уникальных подстрок


def main():
    # s = "abcab"
    # s = "abcabcabc"
    s = "ab"
    print(count_distinct_substrings(s))


if __name__ == "__main__":
    main()