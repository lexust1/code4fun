# Упражнение №3: Количество разных подстрок
# Найти число всех различных подстрок входящих в данную.
def z_func(s, n):
    """
    Вычисляет Z-функцию для строки.

    Args:
    s (str): Строка, для которой вычисляется Z-функция.

    Returns:
    list: Список, содержащий значения Z-функции для каждого индекса строки.
    """
    n = len(s)  # Определяем длину строки s
    z = [0] * n  # Создаем массив Z-функции длины n, инициализированный нулями
    l, r = 0, 0  # Устанавливаем начальные границы самого правого отрезка совпадения
    for i in range(1, n):  # Итерируемся по всем позициям строки, начиная со второй
        if i <= r:  # Проверяем, находится ли текущая позиция i в пределах отрезка [l; r]
            # Инициализируем z[i] меньшим из двух значений:
            # 1. r - i + 1: Максимальное количество символов, которое может совпадать с началом строки,
            #    начиная с позиции i, на основе уже известных данных.
            # 2. z[i - l]: Соответствующее значение Z-функции из предыдущего совпадения.
            # Это предотвращает необходимость в повторных сравнениях символов.
            z[i] = min(r - i + 1, z[i - l])
        # Продолжаем сравнивать символы после предполагаемого совпадения до тех пор,
        # пока они совпадают и пока не достигнут конца строки
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:  # Если новый отрезок совпадения выходит за границу r
            l, r = i, i + z[i] - 1  # Обновляем границы самого правого отрезка совпадения
    return z


def count_substrings(s, z):
    """
    Подсчитывает количество уникальных подстрок в строке, используя Z-функцию.

    Args:
    s (str): Строка, для которой подсчитываются подстроки.
    z (list): Список, содержащий значения Z-функции для каждого индекса строки s.

    Returns:
    int: Количество уникальных подстрок в строке.
    """
    substrings = []  # Список для хранения уникальных подстрок
    i = 0  # Индекс для перебора символов в строке s
    # Итерируемся по значениям Z-функции
    for z_i in z:
        # Если значение Z-функции не равно нулю, то существует подстрока, начинающаяся с i
        if z_i != 0:
            # Вырезаем подстроку длиной z_i, начинающуюся с позиции i
            substring = s[i : i + z_i]
            # Проверяем, встречалась ли такая подстрока ранее
            if substring not in substrings: # для большого количества не очень эффективно, можно усилить через структуры данных
                # Если подстрока уникальна, добавляем ее в список
                substrings.append(substring)
        i += 1  # Переходим к следующему символу в строке

    return len(substrings)


def main():
    # s = "abcdefabcabcdefabcdef"
    s = "abcababckfabct2abjabc"
    z = z_func(s, 21)
    print(z)
    print(count_substrings(s, z))
    # print(calculate_num_of_substrings(z))


if __name__ == "__main__":
    main()
