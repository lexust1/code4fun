# Упражнение №1: Z
# -функция
# Напишите Z
# -функцию. Пусть заголовком ее будет def z_func(s, n):
#
# # O(m + n)
# Основная идея Z-алгоритма заключается в эффективном поиске всех вхождений
# подстроки в строку. Это достигается путем создания специального массива,
# называемого Z-массивом, который для каждой позиции в строке указывает на
# максимальную длину подстроки, начинающейся с этой позиции и совпадающей
# с началом всей строки. Проще говоря, Z-алгоритм помогает быстро определить,
# где и как часто повторяются части строки.
#
# Инициализация Z-массива: Сначала создается массив, где каждый элемент
# изначально равен нулю. Этот массив будет заполнен значениями в процессе
# работы алгоритма.
#
# Поиск Совпадений: Алгоритм проходит по строке и для каждой позиции пытается
# найти максимально длинную подстроку, которая совпадает с началом строки.
# Например, если строка начинается с "абра", алгоритм проверит, начинается ли
# подстрока с позиции 2, 3, 4 и так далее, также с "абра".
#
# Заполнение Z-массива: Каждый раз, когда находится такое совпадение,
# длина этой подстроки записывается в Z-массив на соответствующей позиции.
# Так, если на позиции 5 начинается подстрока "абра", в пятом элементе
# массива будет записано число 4 (длина "абра").
#
# Оптимизация поиска: Алгоритм использует "окно" совпадения и ранее найденные
# значения для уменьшения количества необходимых сравнений. Если часть строки
# уже была проверена и она встречается снова внутри текущего "окна",
# алгоритм использует ранее вычисленные значения, вместо того чтобы снова
# сравнивать символы.
#
# Применение: Полученный Z-массив может быть использован для быстрого
# определения вхождений подстрок в строку, что полезно во многих задачах,
# связанных с обработкой текста.
def z_func(s, n):
    """
    Вычисляет Z-функцию для строки.

    Args:
    s (str): Строка, для которой вычисляется Z-функция.

    Returns:
    list: Список, содержащий значения Z-функции для каждого индекса строки.
    """
    n = len(s)  # Определяем длину строки s
    z = [0] * n  # Создаем массив Z-функции длины n, инициализированный нулями
    l, r = 0, 0  # Устанавливаем начальные границы самого правого отрезка совпадения
    for i in range(1, n):  # Итерируемся по всем позициям строки, начиная со второй
        if i <= r:  # Проверяем, находится ли текущая позиция i в пределах отрезка [l; r]
            # Инициализируем z[i] меньшим из двух значений:
            # 1. r - i + 1: Максимальное количество символов, которое может совпадать с началом строки,
            #    начиная с позиции i, на основе уже известных данных.
            # 2. z[i - l]: Соответствующее значение Z-функции из предыдущего совпадения.
            # Это предотвращает необходимость в повторных сравнениях символов.
            z[i] = min(r - i + 1, z[i - l])
        # Продолжаем сравнивать символы после предполагаемого совпадения до тех пор,
        # пока они совпадают и пока не достигнут конца строки
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:  # Если новый отрезок совпадения выходит за границу r
            l, r = i, i + z[i] - 1  # Обновляем границы самого правого отрезка совпадения
    return z


def main():
    # print(z_func("abababa", 7))
    print(z_func("abcababc", 8))
    # print(z_func("aaaabaa", len("aaaabaa")))


if __name__ == "__main__":
    main()
