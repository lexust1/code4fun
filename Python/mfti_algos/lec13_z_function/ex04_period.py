# Упражнение №4: Период строки
# Для данной строки s найти строку p минимальной длины, такую что s
#  можно предстваить как конкатенацию одной или нескольких копий p.
# Упражнение №3: Количество разных подстрок
# Найти число всех различных подстрок входящих в данную.
def z_func(s, n):
    """
    Вычисляет Z-функцию для строки.

    Args:
    s (str): Строка, для которой вычисляется Z-функция.

    Returns:
    list: Список, содержащий значения Z-функции для каждого индекса строки.
    """
    n = len(s)  # Определяем длину строки s
    z = [0] * n  # Создаем массив Z-функции длины n, инициализированный нулями
    l, r = 0, 0  # Устанавливаем начальные границы самого правого отрезка совпадения
    for i in range(1, n):  # Итерируемся по всем позициям строки, начиная со второй
        if i <= r:  # Проверяем, находится ли текущая позиция i в пределах отрезка [l; r]
            # Инициализируем z[i] меньшим из двух значений:
            # 1. r - i + 1: Максимальное количество символов, которое может совпадать с началом строки,
            #    начиная с позиции i, на основе уже известных данных.
            # 2. z[i - l]: Соответствующее значение Z-функции из предыдущего совпадения.
            # Это предотвращает необходимость в повторных сравнениях символов.
            z[i] = min(r - i + 1, z[i - l])
        # Продолжаем сравнивать символы после предполагаемого совпадения до тех пор,
        # пока они совпадают и пока не достигнут конца строки
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:  # Если новый отрезок совпадения выходит за границу r
            l, r = i, i + z[i] - 1  # Обновляем границы самого правого отрезка совпадения
    return z


def calculate_period(z):
    min_z  = float("inf")
    for el in z:
        if el != 0 and el < min_z:
            min_z = el
    return min_z


def main():
    s = "abcabcabc"
    z = z_func(s, 9)
    print(z)
    print(calculate_period(z))


if __name__ == "__main__":
    main()
