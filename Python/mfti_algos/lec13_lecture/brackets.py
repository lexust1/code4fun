#  Проверка корректности скобочной последовательности.
import a_stack


def is_brace_sequence_correct(s: str) -> bool:
    """
    Проверяет, является ли данная последовательность скобок правильно
    сбалансированной.

    Args:
    s (str): Строка, содержащая скобки. Строка может включать другие
             символы,которые будут игнорироваться. Учитываются только
             круглые "()" и квадратные "[]" скобки.

    Returns:
    bool: True, если последовательность скобок сбалансирована правильно,
          иначе False. Последовательность считается правильно
          сбалансированной, если каждая открывающая скобка
          (либо '(' или '[') соответствует закрывающей скобке
          (либо ')' или ']')
          в правильном порядке.
    """
    a_stack.clear()
    for brace in s:
        # Игнорировать символы, которые не являются скобками
        if brace not in "()[]":
            continue
        # Если символ - открывающая скобка, поместить его в стек
        if brace in "([":
            a_stack.push(brace)
        else:
            # Для закрывающей скобки проверить, пуст ли стек (несоответствующая закрывающая скобка)
            if a_stack.is_empty():
                return False
            # Извлечь верхний элемент стека и проверить на соответствие открывающей скобке
            left = a_stack.pop()
            if left == "(":
                right = ")"
            elif left == "[":
                right = "]"
            # Если скобки не соответствуют друг другу, вернуть False
            if right != brace:
                return False
    # Если стек пуст, все скобки были правильно сопоставлены
    return a_stack.is_empty()


def main():
    print(is_brace_sequence_correct("((f[()])sdf)[]"))
    print(is_brace_sequence_correct("([()]))]"))
    print(is_brace_sequence_correct("("))
    print(is_brace_sequence_correct("]"))


if __name__ == "__main__":
    main()
