# Упражнение №3
# Перевести выражение
#
# Инфиксное выражение. (3+4∗(2−1))/5
# в прямую и обратную польские записи.
#
# В общем и целом, любое выражение можно представить в виде структуры,
# называемой деревом(синтаксическим деревом в данном случае, поскольку
# оно отражает структуру выражения).
# Например, для разобранного выражения синтаксическое дерево будет
# выглядеть так:
#                  /
#                /  \
#               +    5
#              / \
#             *   3
#            / \
#           -   4
#          / \
#         2   1
#
#
# Обработка выражения "(3+4*(2-1))/5" функцией to_postfix:
# 1. '(' встречается первым и помещается в стек.
# 2. '3' является операндом и добавляется в результат.
# 3. '+' помещается в стек, так как он встречается после '('.
# 4. '4' добавляется в результат.
# 5. '*' добавляется в стек, так как он имеет более высокий приоритет, чем '+'.
# 6. Открывающая скобка '(' добавляется в стек.
# 7. '2' добавляется в результат.
# 8. '-' добавляется в стек.
# 9. '1' добавляется в результат.
# 10. При встрече закрывающей скобки ')' извлекаются все операторы до следующей открывающей скобки, '-' добавляется в результат.
# 11. После этого обрабатывается '*', добавляется в результат.
# 12. Следующим символом является ')', при его обработке '+' извлекается из стека и добавляется в результат.
# 13. '/' помещается в стек.
# 14. '5' добавляется в результат.
# 15. В конце, '/' извлекается из стека и добавляется в результат.
# Таким образом, функция преобразует инфиксное выражение "(3+4*(2-1))/5" в постфиксное выражение "3 4 2 1 - * + 5 /".

# Прямая (префиксная) польская нотация: / + 3 * 4 - 2 1 5
# Выполняется на базе обратной польской нотации. См. выше и код.

# Калькуляторы:
# https://www.free-online-calculator-use.com/infix-to-postfix-converter.html
# https://www.free-online-calculator-use.com/infix-to-prefix-converter.html

def get_precedence(c):
    """
    Возвращает приоритет оператора.

    Args:
    c (str): Оператор для определения приоритета.

    Returns:
    int: Числовой приоритет оператора (1 для + и -, 2 для * и /, 3 для ^).
    """
    # Определение приоритета для различных операторов
    if c in ["+", "-"]:
        return 1  # Нижайший приоритет для сложения и вычитания
    if c in ["*", "/"]:
        return 2  # Средний приоритет для умножения и деления
    if c == "^":
        return 3  # Высший приоритет для возведения в степень
    return 0  # Если символ не является оператором


def to_postfix(expression):
    """
    Преобразует инфиксное выражение в постфиксное.

    Args:
    expression (str): Инфиксное выражение для преобразования.

    Returns:
    str: Постфиксное выражение.
    """
    stack = []  # Стек для хранения операторов и скобок
    result = ""  # Результирующая строка для постфиксного выражения
    # Обход всех символов в выражении
    for char in expression:
        if char.isalnum():  # Добавление чисел или переменных в результат
            result += char + " "
        elif char == "(":  # Добавление открывающей скобки в стек
            stack.append(char)
        elif char == ")":  # Обработка закрывающей скобки
            # Извлечение и добавление в результат всех операторов до открывающей скобки
            while stack and stack[-1] != "(":
                result += stack.pop() + " "
            stack.pop()  # Удаление открывающей скобки из стека
        else:
            # Обработка операторов в зависимости от их приоритета
            while stack and get_precedence(char) <= get_precedence(stack[-1]):
                result += stack.pop() + " "
            stack.append(char)  # Добавление текущего оператора в стек
    # Добавление оставшихся операторов из стека в результат
    while stack:
        result += stack.pop() + " "
    return result.strip()


def to_prefix(expression):
    """
    Преобразует инфиксное выражение в префиксное.

    Args:
    expression (str): Инфиксное выражение для преобразования.

    Returns:
    str: Префиксное выражение.
    """
    # Шаг 1: Инвертирование входного выражения.
    # Это делается для того, чтобы обработать выражение справа налево.
    expression = expression[::-1]
    # Шаг 2: Замена скобок и инвертирование операторов.
    # Замена скобок необходима, потому что мы инвертировали выражение.
    # Таким образом, открывающие скобки станут закрывающими и наоборот.
    inverted_expression = []
    for char in expression:
        if char == '(':
            inverted_expression.append(')')
        elif char == ')':
            inverted_expression.append('(')
        else:
            inverted_expression.append(char)
    # Шаг 3: Преобразование инвертированного выражения в постфиксную форму.
    # Используем функцию to_postfix, которая обрабатывает инвертированное
    # выражение и возвращает его в постфиксной форме.
    postfix = to_postfix(''.join(inverted_expression))
    # Шаг 4: Инвертирование постфиксного выражения для получения префиксного.
    # После получения постфиксного выражения мы инвертируем его обратно,
    # чтобы получить окончательное префиксное выражение.
    return postfix[::-1]


def main():
    expression = "(3+4*(2-1))/5"
    # get_precedence
    print("+", get_precedence("+"))
    print("*", get_precedence("*"))
    print("^", get_precedence("^"))
    # to_postfix
    print("Постфиксная нотация:\n", "3 4 2 1 - * + 5 /\n", to_postfix(expression))
    # to_prefix
    print("Префиксная нотация:\n", "/ + 3 * 4 - 2 1 5\n", to_prefix(expression))


if __name__ == "__main__":
    main()
