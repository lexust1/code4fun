# ## [Теория](http://judge.mipt.ru/mipt_cs_on_python3/labs/lab20.html#id10)
#
# В данной лабораторной работе предлагается ознакомиться с библиотекой
# Pygame для 2d графики, анимации, игр и т.п. Начнем с примера.
# Рассмотрим следующее простенькое приложение на Pygame:
#
# **`import** **sysimport** **pygame**pygame.init()
#
# width = 500
# height = 500
#
# screen = pygame.display.set_mode((width, height))
# pygame.display.set_caption('YAHOOOO')
# clock = pygame.time.Clock()
#
# x = 30
# y = 30
# vx = 50
# vy = 50
#
# **while** True:
#     dt = clock.tick(50) / 1000.0
#
#     **for** event **in** pygame.event.get():
#         **if** event.type == pygame.QUIT **or** event.type == pygame.KEYDOWN:
#             sys.exit()
#
#     x += vx * dt
#     y += vy * dt
#
#     screen.fill((0, 0, 0))
#     pygame.draw.circle(screen, (150, 10, 50), (int(x), int(y)), 20)
#
#     pygame.display.flip()`
#
# Если запустить этот код, мы увидим кружок, двигающийся с постоянной
# скоростью.
#
# Разберемся что здесь происходит. Импортировали модуль pygame. Что бы
# работать с этой библиотекой нужно позвать pygame.init() в начале.
# Далее инициализируем окно. Обратите внимание, функции
# pygame.disaplay.set_mode() в качестве параметра передается кортеж из
# ширины и высоты окна. Создали часы (clock), этот объект поможет нам
# считать время между кадрами анимации и контролировать FPS.
#
# Далее идет вечный цикл, в котором мы будем отрисовывать наши кадры и
# обрабатывать события от пользователя (нажатия кнопок, например).
# Что же мы делаем в цикле?
#
# В первую очередь, зовем метод tick() наших часов. Возвращаемое
# значение - время в миллисекундах, прошедшее от предыдущего кадра
# (т.е., на самом деле от предыдущего вызова .tick()). Параметр -
# это ограничение FPS (frames per second - количество кадров в секунду).
# Т.е. с таким параметром метода tick(), часы позаботятся о том, чтобы у
# нас не было больше 50 кадров в секунду. На самом деле, если вы снова
# позовете .tick() раньше положенного времени (1/50 секунды в данном случае),
# то она просто зависнет, пока не пройдет нужное время. Таким образом,
# итерации нашего цикла будут выполняться не друг за другом а через
# паузу. Это необдимо, т.к. цикл вида
#
# **`while** True:
#     **for** event **in** pygame.event.get():
#         **if** event.type == pygame.QUIT **or** event.type == pygame.KEYDOWN:
#             sys.exit()`
#
# сожрет 100% cpu.
#
# В приложениях на Pygame используется событийная модель: программа
# крутится в цикле и обрабатывает поступающие события (нажатия кнопок,
# срабатывание таймера и т.п.). Список событий нам возвращает
# метод `pygame.event.get()`. События при этом удаляются из очереди
# в Pygame, т.е. если позвать этот метод дважды, то во второй раз мы
# не получим события, который получили в первый. Итак, в нашем примере,
# мы всего лишь проверяем, нажал ли пользователь любую клавишу, или
# может закрыл окно (событие QUIT, например если нажать на крестик в
# заголовке окна или Alt+F4), и если да, завершаем выполнение программы
# (только для этого мы и импортировали модуль sys).
#
# Далее, обновляем координаты (no comments).
#
# Далее, две функции рисования. `screen.fill(цвет)` красит весь
# экран (т.е. все наше окошко), `pygame.draw.circle(screen, цвет,
# координаты, радиус)`.
#
# Что характерно:
#
# 1. В обоих случаях нам нужен объект `screen`, который мы получили
# в начале программы, это наше окошко, собственно, где нужно рисовать.
# 2. Координаты в Pygame представлены кортежем целых чисел (x, y).
# Ось x направлена вправо, y вниз. Точка (0,0) находится в левом верхнем
# углу экрана. Заметьте, расчеты координат в примере ведутся в дробных
# числах, т.к. нам нужно точность. Но для рисования мы должны
# преобразовать координаты к типу `int`, т.к. для Pygame
# координаты - это номера пикселей на экране.
# 3. Цвет задается кортежем трех целих чисел: (red, green, blue).
# Каждая составляющая цвета изменяется от 0 до 255. Никогда, пусть вы
# и не художник. не используйте прогерские цвета, вроде (255, 0, 0)
# или (0, 255, 255), будьте чуть более оригинальны.
#
# И последнее. В Pygame все функции рисования не рисуют сразу на
# экране. Они рисуют в некоем скрытом буфере. И только
# вызов `pygame.display.flip()` обновляет экран и отображает все.
# Без вызова `pygame.display.flip()` мы ничего не увидим на экране.
#
# ## [Справка по Pygame](http://judge.mipt.ru/mipt_cs_on_python3/labs/lab20.html#id11)
#
# ### [Часы](http://judge.mipt.ru/mipt_cs_on_python3/labs/lab20.html#id12)
#
# ### [События](http://judge.mipt.ru/mipt_cs_on_python3/labs/lab20.html#id13)
#
# Упражнение №1
# Научите шарик отскакивать от стенок. Постарайтесь также сделать,
# чтоб шарик не залетал за края экрана (самым простым,
# нафизичным способом).
import sys
import pygame


# Инициализация Pygame
pygame.init()
# Установка размеров окна
width = 500
height = 500
# Радиус шарика
radius = 20
# Создание окна для отображения
screen = pygame.display.set_mode((width, height))
# Название окна
pygame.display.set_caption('YAHOOOO')
# Создание объекта Clock для управления временем
clock = pygame.time.Clock()
# Начальные координаты и скорость шарика
x = 30
y = 60
# Скорость по оси X и Y
vx = 50
vy = 50
# Главный цикл игры
while True:
    # Время, прошедшее с последнего кадра (из млс в с)
    dt = clock.tick(50) / 1000.0
    # Обработка событий
    for event in pygame.event.get():
        # Завершение программы при закрытии окна или нажатии любой клавиши
        if event.type == pygame.QUIT or event.type == pygame.KEYDOWN:
            sys.exit()
    # Проверка условий для отражения от стенки
    if x - radius <= 0 or x + radius >= width:
        vx = - vx
    if y - radius <= 0 or y + radius >= height:
        vy = - vy
    # Обновление положения шарика
    x += vx * dt
    y += vy * dt
    # Очистка экрана
    screen.fill((0, 0, 0))
    # Рисование шарика
    pygame.draw.circle(screen, (150, 10, 50), (int(x), int(y)), radius)
    # Обновление содержимого окна
    pygame.display.flip()
