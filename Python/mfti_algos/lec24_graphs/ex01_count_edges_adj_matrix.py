# Сдать решение задачи A-Подсчет количества ребер неориентированного
# графа
#
# Простой неориентированный граф задан матрицей смежности.
# Найдите количество ребер в графе.
#
# Формат входных данных
# На вход программы поступает число n ( 1 <= n <= 100) – количество
# вершин в графе, а затем n строк по n чисел, каждое из которых равно
# 0 или 1, – его матрица смежности.
#
# Формат выходных данных
# Выведите одно число – количество ребер заданного графа.
#
# Примеры
# Ввод	        Вывод
# 5               3
# 0 1 0 0 0
# 1 0 1 0 0
# 0 1 0 0 1
# 0 0 0 0 0
# 0 0 1 0 0
#
def create_input_data():
    adj_matrix = []
    n = 0
    cnt = 0
    while True:
        inp = input()
        if inp == " ":
            break
        if cnt == 0:
            n = int(inp)
        else:
            adj_matrix.append([int(el) for el in inp.split()])
        cnt += 1
    return n, adj_matrix


def count_edges(n, adj_matrix):
    """
    Подсчитывает количество ребер в графе, представленном
    матрицей смежности.

    Аргументы:
    n (int): Количество узлов в графе.
    adj_matrix (list[list[int]]): Матрица смежности графа.

    Возвращает:
    int: Количество ребер в графе.
    """
    # Инициализация счетчика ребер
    m = 0
    # Перебор вершин графа
    for i in range(n):
        # Перебор смежных вершин, каждый раз начинаем с i + 1, чтобы
        # находится над диагональю и не считать два раза одно и то же
        # ребро.
        for j in range(i + 1, n):
            # Проверка наличия ребра между вершинами
            if adj_matrix[i][j] == 1:
                m += 1  # Увеличение счетчика ребер
    return m


def main():
    # print(create_input_data())
    arr1 = (5, [[0, 1, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]])
    print(count_edges(*arr1))


if __name__ == "__main__":
    main()
