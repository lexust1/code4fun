# Сдать решение задачи E-Проверка ацикличности графа

# Дан ориентированный граф. Вершины пронумерованы от 0. Трeбуется с
# помощью обхода в глубину проверить является ли граф ацикличным.
#
# Формат входных данных
# На вход программе в первой строке подаются через пробел два числа:
# N (2 <= N <= 1000) - число вершин в графе и
# M (1 <= M <= 20000) - число ребер.
# В следующих M строках задаются ребра, по два числа в каждой строке -
# номера соединенных вершин (соответствующее ребро идет из первой
# вершины во вторую).
#
# Формат выходных данных
# Требуется распечатать номера вершин, задающих цикл в графе если он
# существует. Номера вершин нужно вывести в порядке следования по циклу.
# Если циклов несколько вывести любой. Если граф ацикличный вывести
# строку "YES" без кавычек.
# #
# Примеры
# Ввод	Вывод
# 4 1     YES
# 3 1
#
#
# Ввод	Вывод
# 8 8     1 6 7 3
# 7 3
# 3 1
# 5 2
# 6 4
# 6 7
# 4 7
# 1 6
# 1 2
def create_adj_list():
    # Задаем число ребер (m) и вершин (n) графа
    n, m = [int(x) for x in input().split()]
    graph = {str(i): set() for i in range(n)}
    # Проходим по всем ребрам графа
    for _ in range(m):
        # Считываем вершины, соединенные ребром
        v1, v2 = input().split()
        # Добавляем вершину v2 в множество соседей вершины v1
        graph[v1].add(v2)
    return graph


def dfs(graph, vertex, stack, color):
    """
    Алгоритм обхода в глубину для поиска циклов в графе.

    Args:
    graph (dict): Граф в виде списка смежности.
    vertex: Текущая вершина.
    visited (set): Набор посещенных вершин.
    stack (list): Стек вершин в текущем пути.
    color (dict): Словарь для отслеживания состояний вершин:
       - Белый: Узел еще не посещен.
       - Серый: Узел посещен и обрабатывается (находится в стеке
       вызова DFS).
       - Черный: Узел и все его потомки полностью обработаны.

    Обнаружение серого узла во время обхода указывает на наличие цикла,
    так как это означает возврат к узлу, который еще не полностью о
    бработан.

    Returns:
    list или None: Список вершин в цикле, если он обнаружен, иначе None.
    """
    # Отмечаем текущую вершину как в процессе обхода
    color[vertex] = 'grey'
    # Добавляем текущую вершину в стек
    stack.append(vertex)
    # Перебираем всех соседей текущей вершины
    for neighbour in graph[vertex]:
        # Если вершину не посещали
        if color[neighbour] == 'white':
            # Рекурсивно вызываем функцию для соседа
            cycle = dfs(graph, neighbour, stack, color)
            # Если рекурсивный вызов dfs обнаружил цикл, немедленно
            # возвращаем этот цикл (список вершин). Это гарантирует,
            # что информация о найденном цикле передается обратно
            # через все уровни рекурсии до первоначального вызова
            # функции.
            if cycle:   # не None от dfs
                return cycle
        # Обнаружена серая вершина, т.е. граф имеет цикл
        elif color[neighbour] == 'grey':
            #  Cрез стека дает нам подсписок, который начинается с
            #  первого вхождения соседа и идет до конца стека.
            #  Это позволяет извлечь цикл, начиная и заканчивая
            #  узлом соседа.
            cycle = stack[stack.index(neighbour):]
            return cycle
    # Удаляем текущую вершину из стека (для сохранения маршрута цикла) и
    # отмечаем её как полностью обработанную
    stack.pop()
    color[vertex] = 'black'
    return None


def is_acyclic_graph(graph):
    """
    Проверяет, является ли граф ацикличным.

    Args:
    graph (dict): Граф представленный в виде словаря.

    Returns:
    str: "YES", если граф ацикличен, иначе список, представляющий
    найденный цикл.
    """
    # Создаем стек для отслеживания вершин цикла
    stack = []
    # Словарь цветов для отметки состояния каждой вершины
    color = {vertex: 'white' for vertex in graph}
    # Проходим по каждой вершине в графе
    for vertex in graph:
        # Если вершина не посещена, выполняем поиск в глубину
        if color[vertex] == 'white':
            cycle = dfs(graph, vertex, stack, color)
            # Если найден цикл, возвращаем его
            if cycle:
                return cycle
    # Если циклы не найдены, возвращаем "YES"
    return "YES"


def main():
    # graph = {
    #     'A': {'B', 'C'},
    #     'B': {'D'},
    #     'C': {'D'},
    #     'D': {'A'}
    # }
    # print(is_acyclic_graph(graph))
    graph = {'0': set(), '1': {'6', '2'}, '2': set(), '3': {'1'}, '4': {'7'}, '5': {'2'}, '6': {'4', '7'}, '7': {'3'}}

    # graph = create_adj_list()
    print(graph)
    print(is_acyclic_graph(graph))


if __name__ == "__main__":
    main()


