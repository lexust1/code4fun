# Сдать решение задачи F-Топологическая сортировка
#
# Дан ориентированный граф. Вершины пронумерованы от 0. Требуется с
# помощью топологической сортировки линейно упорядочить вершины графа в
# список так, чтобы для любого ребра графа из вершины A в вершину B,
# вершина A была левее чем B в списке.
#
# Формат входных данных
# На вход программе в первой строке подаются через пробел два числа:
# N (2 <= N <= 1000) - число вершин в графе и
# M (1 <= M <= 20000) - число ребер.
# В следующих M строках задаются ребра, по два числа в каждой строке -
# номера соединенных вершин (соответствующее ребро идет из первой
# вершины во вторую).
#
# Формат выходных данных
# Требуется распечатать топологически отсортированный список вершин,
# если такой существует. Если упорядочить вершины можно несколькими
# способами выведите любой из них. Если упорядочить вершины нельзя
# выведите "NO" без кавычек.
#
# Примеры
# Ввод	Вывод
# 4 1     0 2 3 1
# 3 1
#
#
# Ввод	Вывод
# 4 4     NO
# 0 1
# 1 2
# 2 3
# 3 1
#
#
# Ввод	Вывод
# 8 10    1 6 4 5 7 3 0 2
# 7 3
# 5 2
# 6 4
# 6 7
# 4 7
# 1 6
# 1 2
# 4 5
# 0 2
# 6 0
#
def create_adj_list():
    # Задаем число ребер (m) и вершин (n) графа
    n, m = [int(x) for x in input().split()]
    graph = {str(i): set() for i in range(n)}
    # Проходим по всем ребрам графа
    for _ in range(m):
        # Считываем вершины, соединенные ребром
        v1, v2 = input().split()
        # Добавляем вершину v2 в множество соседей вершины v1
        graph[v1].add(v2)
    return graph


def dfs(graph, vertex, visited, stack, ans):
    """
    Функция для рекурсивного обхода графа и выполнения топологической
    сортировки при помощи dfs. Теперь также обнаруживает циклы в графе.

    Args:
    graph (dict): Граф, представленный в виде словаря множеств.
    vertex (str): Текущая вершина для обхода.
    visited (set): Множество посещенных вершин.
    stack (set): Множество вершин в текущем стеке вызова.
    ans (list): Список для сохранения порядка топологической сортировки.

    Returns:
    bool: Возвращает False, если найден цикл, иначе True.
    """
    # Добавление текущей вершины в множество посещенных и стек вызова
    visited.add(vertex)
    stack.add(vertex)
    # Перебор всех соседей
    for neighbour in graph[vertex]:
        if neighbour not in visited:
            # Рекурсивный вызов для соседей
            if not dfs(graph, neighbour, visited, stack, ans):
                # Цикл найден
                return False
        elif neighbour in stack:
            # Цикл найден
            return False
    # Удаление вершины из стека вызова и добавление в список ans
    stack.remove(vertex)
    ans.append(vertex)
    return True


def tarjan(graph):
    """
    Функция для выполнения топологической сортировки графа. Теперь также
    проверяет наличие циклов в графе.

    Args:
    graph (dict): Граф, представленный в виде словаря множеств.

    Returns:
    list or str: Список вершин, упорядоченных согласно топологической
        сортировки, или строка "NO", если граф содержит циклы.
    """
    # Список для хранения порядка топологической сортировки
    ans = []
    # Множество для отслеживания посещенных вершин
    visited = set()
    # Множество для отслеживания вершин в текущем стеке вызова
    stack = set()
    # Вызов DFS для каждой непосещенной вершины (а не соседа), по сути,
    # со стартом из разных вершин.
    for vertex in graph:
        if vertex not in visited:
            # Обход в глубину для каждой вершины пока не дойдем до
            # цикла.
            if not dfs(graph, vertex, visited, stack, ans):
                # Цикл найден, топологическая сортировка невозможна
                return "NO"
    # Реверсирование списка для получения правильного порядка
    ans.reverse()
    return ans


def main():
    # graph = {'0': {'2'}, '1': {'6', '2'}, '2': set(), '3': set(), '4': {'5', '7'}, '5': {'2'}, '6': {'0', '4', '7'}, '7': {'3'}}
    graph = create_adj_list()
    print(graph)
    print(tarjan(graph))


if __name__ == "__main__":
    main()
