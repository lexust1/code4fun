# Сдать решение задачи D-Полуполный граф
#
# Ориентированный граф называется полуполным, если между любой парой
# его различных вершин есть хотя бы одно ребро. Для заданного списком
# ребер графа проверьте, является ли он полуполным.
#
# Формат входных данных
# Сначала вводятся числа n ( 1 <= n <= 100) – количество вершин в графе
# и m ( 1 <= m <= n(n - 1)) – количество ребер. Затем следует m пар
# чисел – ребра графа. Номера вершин начинаются с 0.
#
# Формат выходных данных
# Выведите «YES», если граф является полуполным, и «NO» в противном
# случае.
#
# Примеры
# Ввод	Вывод
# 2 1     YES
# 1 0
#
#
# Ввод	Вывод
# 5 10    NO
# 0 1
# 0 2
# 0 4
# 1 2
# 1 4
# 2 1
# 3 0
# 3 2
# 3 4
# 4 2
#

# Для решения задачи будем использовать матрицу смежности по следующим
# причинам:
# - Полуполный граф говорит о том, что у нас граф, насыщенный связями.
# Т.е. список смежности для каждой из вершин не будет на порядок
# отличаться от строки матрицы смежности.
# - Нам в любом случае придется пробегаться через все вершины напротив
# всех вершин, т.е. асимптотика словаря здесь не даст особого выйгрыша.
def create_adj_matrix():
    # Задаем число ребер (m) и вершин (n) графа
    n, m = [int(x) for x in input().split()]
    # Создаем список вершин (vs) и словарь для отслеживания индексов каждой вершины (index)
    vs = []
    index = {}
    # Инициализация матрицы смежности размером n x n (n вершин)
    arr = [[0] * n for _ in range(n)]
    # Проходим через m ребер графа (вводим их и размещаем в матрице смежности)
    for _ in range(m):
        # Считываем две вершины, соединенные ребром
        v1, v2 = input().split()
        # Для каждой вершины в ребре
        for v in v1, v2:
            # Если вершина еще не добавлена, добавляем ее в список V и в словарь index
            if v not in index:
                vs.append(v)
                index[v] = len(vs) - 1
        # Получаем индексы вершин в матрице смежности
        v1_idx = index[v1]
        v2_idx = index[v2]
        # Устанавливаем соответствующие значения в матрице смежности в 1 (наличие ребра)
        arr[v1_idx][v2_idx] = 1
    return n, arr


def is_semi_completed_graph(n, arr):
    """
    Проверяет, является ли граф полузавершенным.

    Args:
    - n: int, количество узлов в графе
    - arr: список списков, матрица смежности графа

    Returns:
    - str, "YES", если граф полузавершенный, иначе "NO"
    """
    # Перебираем все пары узлов
    for i in range(n):
        for j in range(n):
            # Проверяем отсутствие ребра в обоих направлениях
            if i != j and not (arr[i][j] or arr[j][i]):
                return "NO"
    return "YES"


def main():
    print(is_semi_completed_graph(*create_adj_matrix()))


if __name__ == "__main__":
    main()
