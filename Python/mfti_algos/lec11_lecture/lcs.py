# НОП, или Наибольшая Общая Подпоследовательность (Longest Common
# Subsequence, LCS), представляет собой наибольшую по длине
# последовательность элементов, которая может быть обнаружена в каждой
# из двух или более данных последовательностей, сохраняя при этом
# порядок следования элементов. Важно отметить, что элементы НОП не
# обязаны следовать непрерывно в исходных последовательностях.
#
# Например, если у нас есть две строки "ABCBDAB" и "BDCAB", то НОП для
# этих строк может быть "BDAB" или "BCAB". В каждом из этих примеров
# символы НОП встречаются в том же порядке, в каком они появляются в
# обеих строках, но между некоторыми из символов могут быть другие
# символы или они могут быть в разных местах строк.

# Суть алгоритма: мы берем два слова (последовательности) и по аналогии
# с заданием с ферзем устанавливаем 1-е слово по горизонтали, 2-е по
# вертикали. Далее вычисляем максимальную длину последовательности,
# используя каждую ячейку для хранения информации о совпадении:
# a) если буквы обоих слов (последовательностей) совпадают, то мы
# добавляем +1 к значению из ячейки по диагонали слева.
# б) если буквы обоих слов (последовательностей) разные, то мы
# ничего не добавляем, а берем максимальное значение из значений сверху
# и слева.



def lcs_length(seq1, seq2):
    """
    Вычисляет длину наибольшей общей подпоследовательности (НОП) двух
    строк.

    Подпоследовательность состоит из элементов, которые появляются в
    обеих строках в том же порядке, но не обязательно подряд.
    Функция использует метод динамического программирования.

    Args:
    seq1 (str): Первая строка для сравнения.
    seq2 (str): Вторая строка для сравнения.

    Returns:
    int: Длина наибольшей общей подпоследовательности двух строк.
    """
    # Длины входных строк
    n, m = len(seq1), len(seq2)
    # Инициализация таблицы для динамического программирования
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    # Заполнение таблицы: проход по всем символам обеих строк
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            # Если символы совпадают
            if seq1[i - 1] == seq2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            # Если символы не совпадают
            else:
                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
    # Возвращаем значение в правом нижнем углу таблицы, которое
    # является длиной НОП
    return dp[-1][-1]


def main():
    print(lcs_length("fish", "fosh"))
    print(lcs_length("ABCBDAB", "BDCAB"))


if __name__ == "__main__":
    main()
