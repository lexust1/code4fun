# Наибольшая возрастающая подпоследовательность (НВП) — это
# подпоследовательность данной последовательности чисел, в которой
# каждый элемент строго больше предыдущего. Главное отличие НВП от
# других видов подпоследовательностей заключается в том, что элементы
# в НВП должны следовать в строго возрастающем порядке.
#
# Исходная последовательность: [10, 20, 9, 33]
# НВП: [10, 20, 33]
# Объяснение: Здесь 10 < 20 < 33, так что это возрастающая
# последовательность. Хотя 9 меньше 20, оно не входит в
# подпоследовательность, так как идет после 20.

# Суть алгоритма, что мы формируем подпоследовательности из
# последовательности, каждый раз увеличивая на один элемент. При этом
# последний элемент последовательности сравниваем с каждым из
# предыдущих. Количество превышений учитывае в отдельном массиве,
# добавляя 1.


def lis_length(seq):
    """
    Вычисляет длину наибольшей возрастающей подпоследовательности (НВП)
    в массиве.

    НВП - это подпоследовательность данной последовательности,
    в которой элементы строго возрастают.
    Этот метод использует динамическое программирование для
    эффективного вычисления длины НВП.

    Args:
    arr (list): Список или массив чисел для нахождения НВП.

    Returns:
    int: Длина наибольшей возрастающей подпоследовательности в массиве.
    """
    if not seq:
        return 0
    n = len(seq)
    # Инициализация массива для хранения длин НВП для каждого элемента
    dp = [1] * n
    # Вычисление НВП для каждого элемента
    for i in range(1, n):  # Проходим по всем элементам массива, начиная со второго
        for j in range(i):  # Для каждого i-го элемента проходим по всем предыдущим элементам
            if seq[i] > seq[j]:  # Проверяем, образует ли пара (seq[j], seq[i]) возрастающую подпоследовательность
                # Если seq[i] больше seq[j], тогда элемент seq[i] может продолжить возрастающую подпоследовательность,
                # заканчивающуюся на seq[j]. Теперь нужно проверить, увеличит ли это длину НВП.
                dp[i] = max(dp[i], dp[j] + 1)  # Обновляем dp[i]:
                # dp[i] - текущая максимальная длина НВП, заканчивающейся на seq[i]
                # dp[j] + 1 - длина новой возрастающей подпоследовательности, если к dp[j] добавить текущий элемент seq[i]
                # Мы выбираем максимальное из этих двух значений.
    # Возвращаем максимальное значение из dp, что является длиной НВП
    # всей последовательности
    return max(dp)


def main():
    print(lis_length([10, 22, 9, 33, 21, 50, 41, 60, 80]))


if __name__ == "__main__":
    main()
